<!DOCTYPE html>
<html lang="en-us">

  <head>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <meta name="description" content="Jeremy Cochoy's personal website.">
  <meta name="author" content="Jeremy Cochoy">

  <title>
    
      What is wrong with the object paradigm ? &middot; Jeremy Cochoy
    
  </title>

  <!-- CSS -->
  <link href="/public/bootstrap/css/bootstrap.min.css" rel="stylesheet">
  <link rel="stylesheet" href="/public/css/poole.css">
  <link rel="stylesheet" href="/public/css/syntax.css">
  <link rel="stylesheet" href="/public/css/hyde.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">
  <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
  <!--[if lt IE 9]>
  	<script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
  	<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
	<![endif]-->

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/apple-touch-icon-precomposed.png">
  <link rel="shortcut icon" href="/public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">

  <!-- Custom styles for this template -->
  <link href="/public/style.css" rel="stylesheet">

  <!-- Maths equations -->
  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$','$'], ['\\(','\\)']],
      processEscapes: true
    }
  });
  </script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
</head>


  <body>

    <!-- Fixed navbar -->
<nav class="navbar navbar-default navbar-fixed-top">
 <div class="container">
   <div class="navbar-header">
     <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
 <span class="sr-only">Toggle navigation</span>
 <span class="icon-bar"></span>
 <span class="icon-bar"></span>
 <span class="icon-bar"></span>
     </button>
     <a class="navbar-brand" href="/">Jeremy Cochoy</a>
   </div>
   <div id="navbar" class="collapse navbar-collapse">
     <ul class="nav navbar-nav">
 <li><a href="/blog/">Blog</a></li>
 <li><a href="/resume/">Resume</a></li>
 <li role="separator" class="divider"></li>
 <li><a href="/research/">Research</a></li>
 <li><a href="/talks/">Talks</a></li>
 <li><a href="/teaching/">Teaching</a></li>
 <li><a href="/music/">Music</a></li>
 <li class="dropdown">
   <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">More <span class="caret"></span></a>
   <ul class="dropdown-menu">
     <li><a href="/hyper-flop/">Hyper-Flop</a></li>
     <li role="separator" class="divider"></li>
     <li><a href="/pdfs/">PDFs & Talks</a></li>
     <li><a href="/agreg-dev/">Agregation de math√©matique</a></li>
     <li role="separator" class="divider"></li>
     <li><a href="https://github.com/jeremycochoy/sednl" alt="SEDNL Github">SEDNL (Github)</a></li>
     <li><a href="http://sednl.zenol.fr" alt="Simple Event Driven Network Library">SEDNL</a></li>
           <li role="separator" class="divider"></li>
           <li><a href="/gb-doc">GameBoy Emulator Documentation</a></li>
   </ul>
 </li>
     </ul>
   </div><!--/.nav-collapse -->
 </div>
</nav>


    <div class="container">
      <div class="post">
  <h1 class="post-title">What is wrong with the object paradigm ?</h1>
  <span class="post-date">17 Feb 2017</span>
  <p>Disclaimer: Aside from the catchy title,
the main point of this article is to asks questions about the weakness of OOP
and how some languages provided some element of improvement, by taking a slightly different point of view.</p>

<blockquote>
  <p>The object paradigm is fundamentally wrong<sup id="fnref:wrong"><a href="#fn:wrong" class="footnote">1</a></sup></p>
</blockquote>

<p>If you are curious about programming languages and diverse paradigms,
you probably heard or read this sentence more than once.
Through those lines,
I‚Äôll try to draw a picture of the main reason that can lead peoples to this conclusion.
What are the good side and wrong side of OOP,
and how we can improve this paradigm by tuning it a little bit.
This nice ‚Äútunning‚Äù is actually already part of some languages,
and I‚Äôll refer to it as the ‚Äòcategory paradigm‚Äô.</p>

<h2 id="where-does-the-object-paradigm-comes-from">Where does the object paradigm comes from?</h2>

<p>First, let‚Äôs recall how, historically, we came to the object paradigm.
We are in the late 70s.
The C language is now famous as it completely changed the way to write code
compared to assembly, is human readable and have a monstrous expressivity
in only few language words and
the procedural paradigm<sup id="fnref:procedural-paradigm"><a href="#fn:procedural-paradigm" class="footnote">2</a></sup> (the one you use while writing C)
is well understood.
But, as applications grow and get an increasing size,
developers are facing an increasingly common problem:
the code‚Äôs complexity is growing exponentially, and code gets harder and harder to write
(it still sounds like a today‚Äôs problem, right? :-) ).
The object paradigm was developed, expecting to solve the complexity curse.
Here came OBJC and C++, both in 1983.</p>

<p>Sadly, we know today that OOP wasn‚Äôt the Holly Graal.
But what did made peoples believe that it would be, and why is OOP still used today?</p>

<h2 id="the-hopes-of-oop">The hopes of OOP</h2>

<p>What came out from a lot of procedural development is that you often have types
that describe some complex structure (for example, linked lists in C are built of chained cells,
each cell composed of a value and a link to the next cell)
and functions operating on this type (using the same example,
function for initialising empty list, destroying list,
inserting into this list and removing value from it, etc.).
Once you have spotted this coding pattern, it sounds reasonable to formalise it so that
you don‚Äôt always have to rewrite it by hand, each time.
Indeed, this is the best way to involve : spot a pattern that people do mechanically,
and automatise it.
It worked in the automobile industry,
and it also did for computer development.
Automatization, from shell script‚Ä¶ to new programming languages.</p>

<h2 id="genesis-of-oop">Genesis of OOP</h2>

<p>This was the genese of the object paradigm.
We call a such data type an object, add an
initialisation procedure always called at initialisation,
and an other one always called when the resource become unreachable.
Namely, OOP‚Äôs constructor and destructors.
Because we always have lots of methods related to this object that
always need as argument this object,
we add them to the type definition and call them methods.</p>

<p>Here is an example of the C object pattern :</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">object_type</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">value1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">value2</span><span class="p">;</span>
    <span class="kt">char</span><span class="o">*</span> <span class="n">ptr</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">initialize_object</span><span class="p">(</span><span class="k">struct</span> <span class="n">object_type</span><span class="o">*</span> <span class="n">obj</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">obj</span><span class="o">-&gt;</span><span class="n">value1</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
    <span class="n">obj</span><span class="o">-&gt;</span><span class="n">value2</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
    <span class="n">obj</span><span class="o">-&gt;</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">calloc</span><span class="p">(</span><span class="mi">42</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">));</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">release_object</span><span class="p">(</span><span class="k">struct</span> <span class="n">object_type</span><span class="o">*</span> <span class="n">obj</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">free</span><span class="p">(</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">do_stuff</span><span class="p">(</span><span class="k">struct</span> <span class="n">object_type</span><span class="o">*</span> <span class="n">obj</span><span class="p">,</span> <span class="kt">int</span> <span class="n">input</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">obj</span><span class="o">-&gt;</span><span class="n">value1</span> <span class="o">+=</span> <span class="n">input</span><span class="p">;</span>
    <span class="n">obj</span><span class="o">-&gt;</span><span class="n">value2</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">obj</span><span class="o">-&gt;</span><span class="n">value1</span> <span class="o">+</span> <span class="n">obj</span><span class="o">-&gt;</span><span class="n">value2</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">//...</span>
<span class="k">struct</span> <span class="n">object_type</span> <span class="n">obj</span><span class="p">;</span>

<span class="p">{</span>
    <span class="n">initialize_object</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj</span><span class="p">);</span>
    <span class="n">do_stuff</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
    <span class="n">release_object</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj</span><span class="p">);</span>
<span class="p">}</span>

</code></pre></div></div>

<p>And the same thing now in C++:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Object</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">Object</span><span class="p">();</span>
    <span class="o">~</span><span class="n">Object</span><span class="p">();</span>
    <span class="kt">int</span> <span class="n">do_stuff</span><span class="p">(</span><span class="kt">int</span> <span class="n">input</span><span class="p">);</span>
<span class="nl">private:</span>
    <span class="kt">int</span> <span class="n">value1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">value2</span><span class="p">;</span>
    <span class="kt">char</span><span class="o">*</span> <span class="n">ptr</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">Object</span><span class="o">::</span><span class="n">Object</span><span class="p">()</span>
    <span class="o">:</span><span class="n">value1</span><span class="p">(</span><span class="mi">7</span><span class="p">),</span> <span class="n">value2</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ptr</span> <span class="o">=</span> <span class="n">calloc</span><span class="p">(</span><span class="mi">42</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">));</span>
<span class="p">};</span>

<span class="n">Object</span><span class="o">::~</span><span class="n">Object</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">free</span><span class="p">(</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">Object</span><span class="o">::</span><span class="n">do_stuff</span><span class="p">(</span><span class="kt">int</span> <span class="n">input</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">value1</span> <span class="o">+=</span> <span class="n">input</span><span class="p">;</span>
    <span class="n">value2</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">value1</span> <span class="o">+</span> <span class="n">value2</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">//...</span>
<span class="p">{</span>
    <span class="n">Object</span> <span class="n">obj</span><span class="p">;</span>
    <span class="n">obj</span><span class="p">.</span><span class="n">do_stuff</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This example is quite simple, and show how object paradigm is applied
both in C and C++ languages.
The second language is a lot more error-proof thanks to
the support of the paradigm <em>in</em> the language.</p>

<p>Now you might interupt me and argue ‚Äòobject paradim isn‚Äôt just about methods glued to a type‚Äô.
And you would be right.
I swept under the rug <em>inheritence</em>.
This feature actually comes from spotting another codding patter C developers were also
doing quite frequently.
You reproduce the inheritence by agregating types, and using pointer arithmetic,
as shown below.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">A</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">u</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">B</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">A</span> <span class="n">parent</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">v</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">C</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">A</span> <span class="n">parent</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">w</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">B</span> <span class="n">obj_b</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">C</span> <span class="n">obj_c</span><span class="p">;</span>
<span class="c1">// Upcasting</span>
<span class="k">struct</span> <span class="n">A</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">obj_b</span><span class="p">.</span><span class="n">parent</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">A</span><span class="o">*</span> <span class="n">q</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">obj_c</span><span class="p">.</span><span class="n">parent</span><span class="p">;</span>

</code></pre></div></div>

<p>The same code in C++ would be:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1">// In C++, the struct keyword is like the class keyword,</span>
<span class="c1">// but all elements are by default public.</span>

<span class="k">struct</span> <span class="n">A</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">u</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">B</span> <span class="o">:</span> <span class="k">public</span> <span class="n">A</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">v</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">C</span> <span class="o">:</span> <span class="k">public</span> <span class="n">A</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">w</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">B</span> <span class="n">obj_b</span><span class="p">;</span>
<span class="n">C</span> <span class="n">obj_c</span><span class="p">;</span>
<span class="c1">// Upcasting</span>
<span class="n">A</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">obj_b</span><span class="p">;</span>
<span class="n">A</span><span class="o">*</span> <span class="n">q</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">obj_c</span><span class="p">;</span>

</code></pre></div></div>

<p>Introducing this feature in the language ensure automatic conversion from B* to A* with
the right pointer arithmetic.
It remove the risk of often hard to spot bugs.
Inheriting doesn‚Äôt apply only to type, it apply to methods.
You can call methods working with a type A on instance of type B.
This is the key reason of this pointer conversion.</p>

<p>The languages C++ and Java alow something even stronguer than reusing methode
for subtypes in inheritence hierarchy.
Through abstract methods, or Java‚Äôs interface,
you can force the existence of methods on a given type.
Such that the behavior can be different with different types,
but the interface to work on them remind the same.
Allowing huge code factorisation and genericity of algorithms.</p>

<h2 id="so-why-is-oop-wrong">So why is OOP wrong?</h2>

<p>Before saying anything,
I want to show you how does object looks like in different mainstream languages.</p>

<p><img src="data/object-languages.png" alt="Object Languages" /></p>

<p>Of course, you can make schemes similar to java in C++ ;
interface are obtained through abstract class.
It‚Äôs just that the language doesn‚Äôt prevent you from gluing too many things together
(but that‚Äôs actually part of the C++ philosophy : allow doing
as much thing as you can imagine, but you have to make carefully your design decisions).</p>

<p>Looking at the scheme, we see that always, in both languages,
type definition and method definitions are glued together.
You <strong>can not</strong> define a type and later,
in a completely independent way, implement methods for this type.
Actually, if C++ and Java are the only object languages you have heard about,
my last sentence might sounds really strange for you (even maybe sounds like nonsense).
But notice that in D, you <strong>can</strong> implement something rely similar to methods in a
complementary independent way of type definition.
Why would you do that? Let me give you a tasty example.</p>

<p>A guy (let call him A) make a colorful library describing tasty chocolate biscuits.
Here is a little bit of his library.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Biscuit -&gt; Cookie -&gt; FullChocolateCookie
                  -&gt; WhiteAndBlackCookie
        -&gt; Oreo
</code></pre></div></div>

<p>He think a lot about cooking such wonderful wonders, an implement many sophisticated methods.</p>

<p>Now another guy (named B) just discovered the best way to eat biscuits,
so that you can really enjoy all the taste and perfume they carry.
Not only for chocolate biscuits, but for any biscuit in the world.
He implements many new biscuit, and their <em>eat</em> method.
But in those languages, his only way to add an <em>eat</em> method to A‚Äôs cookies is to either:</p>

<ul>
  <li>Re-implement all the biscuit A did in his library, or modify A‚Äôs library to add his eat method,</li>
  <li>Encapsulate the A library in some container, like a ‚Äòbiscuit metal box‚Äô, which is definitively not as easy to eat (especially because metal tends to be harder your teeth).</li>
</ul>

<p>If you develop library and re-use existing libraries,
that‚Äôs a problem you probably already encountered many times.</p>

<p>This is because there is actually no good reason to enforce (Java style)
interface implementation where type definition occurs.
This is the first big issue coming from the way object model
is implemented <strong>and</strong> conceived in developer‚Äôs mind.</p>

<p>The second big issue, related to the way OOP is done today,
is the huge verbosity and boilerplate code introduced by encapsulation.
Good books like ‚Äòeffective C++‚Äô<sup id="fnref:effective-cpp"><a href="#fn:effective-cpp" class="footnote">3</a></sup> even recommend doing so.
You see it everyday, from getters and setters mostly doing one-line affectation
(many ide have tools for automating this code generation) to constructor
only forwarding argument to member variables.
I really like the following example from LLVM‚Äôs documentation:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">AST</span> <span class="n">Bidule</span> <span class="p">{</span>
    <span class="n">ASTBidule</span><span class="p">(</span><span class="n">t1</span> <span class="n">a</span><span class="p">,</span> <span class="n">t2</span> <span class="n">b</span><span class="p">,</span> <span class="n">t3</span> <span class="n">c</span><span class="p">)</span>
    <span class="o">:</span><span class="n">a</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">b</span><span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="n">c</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="p">{};</span>

    <span class="n">t1</span> <span class="n">a</span><span class="p">;</span>
    <span class="n">t2</span> <span class="n">b</span><span class="p">;</span>
    <span class="n">t3</span> <span class="n">c</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>So much redundancy.
Have a look at LLVM‚Äôs example for heavily verbose C++ code
(that is actually good C++ practice‚Ä¶).
Each variable‚Äôs name is written three times.
I would say that this code is three times longer that it should be
(I mean, if we was living in a perfect world).
But there isn‚Äôt a better way to do it, conforming to usual understanding of OOP.
If so, LLVM‚Äôs developer would have found it and spreed the word.</p>

<h2 id="the-categoric-paradigm">The categoric paradigm</h2>

<p>What I call categoric paradigm is a way of doing OOP in some functional languages
like Haskell, but also Rust.
Up to a certain amount it can also be done in D.</p>

<p>The main idea is that types remain types (aggregated data),
functions and procedure remain procedures.
Sets of procedures can be regrouped together in a typeclass definition.
A typeclass (it‚Äôs a mathematical class) definition is similar to a java interface.
Types that become instances of this typeclass should implement its methods, but
the main difference is that the belonging of a type T to a given typeclass C can be
stated independently of the typeclass definition and of the type definition.
In rust, typeclass are named trait.
Types are types (as they are in C) and the link between them, the instanciation of
the trait of a type can be done independently of the definition of the trait and of
the definition of the type.</p>

<p>Here is bellow a short example from rust‚Äôs documentation<sup id="fnref:trait"><a href="#fn:trait" class="footnote">4</a></sup>:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// # A Sheep object:</span>

<span class="k">struct</span> <span class="n">Sheep</span> <span class="p">{</span> <span class="n">naked</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'static</span> <span class="nb">str</span> <span class="p">}</span>

<span class="k">impl</span> <span class="n">Sheep</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">is_naked</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.naked</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">shear</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="nf">.is_naked</span><span class="p">()</span> <span class="p">{</span>
            <span class="c">// Implementor methods can use the implementor's trait methods.</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"{} is already naked..."</span><span class="p">,</span> <span class="k">self</span><span class="nf">.name</span><span class="p">());</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"{} gets a haircut!"</span><span class="p">,</span> <span class="k">self</span><span class="py">.name</span><span class="p">);</span>

            <span class="k">self</span><span class="py">.naked</span> <span class="o">=</span> <span class="k">true</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c">// # The Animal typeclass/trait/interface:</span>
<span class="k">trait</span> <span class="n">Animal</span> <span class="p">{</span>
    <span class="c">// Static method signature; `Self` refers to the implementor type.</span>
    <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">name</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'static</span> <span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Self</span><span class="p">;</span>

    <span class="c">// Instance method signatures; these will return a string.</span>
    <span class="k">fn</span> <span class="nf">name</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="nv">'static</span> <span class="nb">str</span><span class="p">;</span>
    <span class="k">fn</span> <span class="nf">noise</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="nv">'static</span> <span class="nb">str</span><span class="p">;</span>

    <span class="c">// Traits can provide default method definitions.</span>
    <span class="k">fn</span> <span class="nf">talk</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"{} says {}"</span><span class="p">,</span> <span class="k">self</span><span class="nf">.name</span><span class="p">(),</span> <span class="k">self</span><span class="nf">.noise</span><span class="p">());</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c">// # The implementation of the `Animal` trait for the type `Sheep`.</span>
<span class="k">impl</span> <span class="n">Animal</span> <span class="k">for</span> <span class="n">Sheep</span> <span class="p">{</span>
    <span class="c">// `Self` is the implementor type: `Sheep`.</span>
    <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">name</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'static</span> <span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Sheep</span> <span class="p">{</span>
        <span class="n">Sheep</span> <span class="p">{</span> <span class="n">name</span><span class="p">:</span> <span class="n">name</span><span class="p">,</span> <span class="n">naked</span><span class="p">:</span> <span class="k">false</span> <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">name</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="nv">'static</span> <span class="nb">str</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.name</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">noise</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="nv">'static</span> <span class="nb">str</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="nf">.is_naked</span><span class="p">()</span> <span class="p">{</span>
            <span class="s">"baaaaah?"</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="s">"baaaaah!"</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c">// Default trait methods can be overridden.</span>
    <span class="k">fn</span> <span class="nf">talk</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="c">// For example, we can add some quiet contemplation.</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"{} pauses briefly... {}"</span><span class="p">,</span> <span class="k">self</span><span class="py">.name</span><span class="p">,</span> <span class="k">self</span><span class="nf">.noise</span><span class="p">());</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>See how this three things can be done independently.</p>

<p>Similar things can be archived in haskell,
though constructor and destructor doesn‚Äôt exist.
But Haskell‚Äôs variable are by default immutable,
and the language is full of laziness.
In a such context, looking for a constructor or a destructor doesn‚Äôt make sens.
But for the curious, what is done in rust for methods can be done in the
same way in Haskell.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Though this article have a really catchy title,
the main point is to show you another perspective for the concept of object
that is quite different from the one OOP‚Äôs developer are used to.
The first goal is to show the weakness of the object paradigm,
and the second is to demonstrate how some of them can be strengthen
from a small switch in the viewpoint, using emerging languages for examples.
The view point demonstrated here is more known in the functional programming land
(although not all functional programming languages offers such features).
The Mozilla fondation made a wonderful work by creating rust, a language that provide
both the functional and procedural paradigms, and also allow taking the
object approach in cases where it fits better than the two previous paradigms.
I hope that it made you question yourself on the object oriented paradigm and
developed your curiosity for other languages.
The other languages mentioned are not mainstream, but the ideas they carry
appear increasingly in many languages and if we cannot say which language will be
the language of tomorrow, we can be sure that this language will provide many
tools that are common in the functional world, probably together with
our usual tools from procedural languages. So don‚Äôt turn your head away,
just because your favorite language doesn‚Äôt provide such features :)</p>

<div class="footnotes">
  <ol>
    <li id="fn:wrong">
      <p>Things aren‚Äôt black and white. The object paradigm is definitively well suited
for many tasks like modeling GUI.¬†<a href="#fnref:wrong" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:procedural-paradigm">
      <p>Procedural paradigm means essentially
that the language provide functions with side effects, and code is written linearly.
You can see it like an enhencement of languages that only provide goto and jumps.¬†<a href="#fnref:procedural-paradigm" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:effective-cpp">
      <p>This is a really good book on good programming advices
for C++ developer. Despite the critic made in this article, it‚Äôs definitively
a book full of good practices.¬†<a href="#fnref:effective-cpp" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:trait">
      <p>See <a href="http://rustbyexample.com/trait.html">rust traits</a>¬†<a href="#fnref:trait" class="reversefootnote">&#8617;</a></p>
    </li>
  </ol>
</div>

</div>

<div class="related">
  <h2>Related Posts</h2>
  <ul class="related-posts">
    
      <li>
        <h3>
          <a href="/list-zipper-swift/">
            List Zipper applied to iOS swift
            <small>24 May 2019</small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/boost-property-tree/">
            How to use boost::property_tree to load and write JSON
            <small>21 Dec 2015</small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/an-alternative-error-handling-strategy-cpp/">
            An alternative error handling strategy for C++
            <small>27 Aug 2013</small>
          </a>
        </h3>
      </li>
    
  </ul>
</div>

    </div>

    
    <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-10762787-1', 'auto');
    ga('send', 'pageview');
</script>
    

    <footer class="footer">
  <hr/>
  <div class="container">
    <div class="row">
      <p class="text-muted col-sm-10 text-center">
            <span class="sidebar-nav-item small">Make a donation. üòá</span>
            <span class="sidebar-nav-item x-small">BTC: <a href="bitcoin:1JcME7DSCw8b83nEGFKUYTKE4LM8aX4dhJ">1JcME7DSCw8b83nEGFKUYTKE4LM8aX4dhJ</a></span>
            <span class="sidebar-nav-item x-small">ETH: <a href="ethereum:eA22ADf19f20D618D8EF66E4704C540A10708F1F">eA22ADf19f20D618D8EF66E4704C540A10708F1F</a></span>
      </p>
      <p class="col-sm-2">
        <a class="twitter-share-button col-sm"
           href="https://twitter.com/share"
           data-via="Zenol42">
          Tweet
        </a>
      </p>
    </div>
  </div>
</footer>

<!-- Bootstrap core JavaScript
================================================== -->
<!-- Placed at the end of the document so the pages load faster -->
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="/bootstrap/js/vendor/jquery.min.js"><\/script>')</script>
<script src="/public/bootstrap/js/bootstrap.min.js"></script>

<!-- Twitter sharing button loader -->
<script>
  window.twttr = (function(d, s, id) {
    var js, fjs = d.getElementsByTagName(s)[0],
      t = window.twttr || {};
    if (d.getElementById(id)) return t;
    js = d.createElement(s);
    js.id = id;
    js.src = "https://platform.twitter.com/widgets.js";
    fjs.parentNode.insertBefore(js, fjs);

    t._e = [];
    t.ready = function(f) {
      t._e.push(f);
    };

    return t;
  }(document, "script", "twitter-wjs"));
</script>

  </body>
</html>
