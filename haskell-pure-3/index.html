<!DOCTYPE html>
<html lang="en-us">

  <head>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <meta name="description" content="Jeremy Cochoy's personal website.">
  <meta name="author" content="Jeremy Cochoy">

  <title>
    
      Le Haskell, un langage au label pure. Troisième partie. &middot; Jeremy Cochoy
    
  </title>

  <!-- CSS -->
  <link href="/public/bootstrap/css/bootstrap.min.css" rel="stylesheet">
  <link rel="stylesheet" href="/public/css/poole.css">
  <link rel="stylesheet" href="/public/css/syntax.css">
  <link rel="stylesheet" href="/public/css/hyde.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">
  <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
  <!--[if lt IE 9]>
  	<script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
  	<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
	<![endif]-->

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/apple-touch-icon-precomposed.png">
  <link rel="shortcut icon" href="/public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">

  <!-- Custom styles for this template -->
  <link href="/public/style.css" rel="stylesheet">

  <!-- Maths equations -->
  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$','$'], ['\\(','\\)']],
      processEscapes: true
    }
  });
  </script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
</head>


  <body>

    <!-- Fixed navbar -->
<nav class="navbar navbar-default navbar-fixed-top">
 <div class="container">
   <div class="navbar-header">
     <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
 <span class="sr-only">Toggle navigation</span>
 <span class="icon-bar"></span>
 <span class="icon-bar"></span>
 <span class="icon-bar"></span>
     </button>
     <a class="navbar-brand" href="/">Jeremy Cochoy</a>
   </div>
   <div id="navbar" class="collapse navbar-collapse">
     <ul class="nav navbar-nav">
 <li><a href="/blog/">Blog</a></li>
 <li><a href="/resume/">Resume</a></li>
 <li role="separator" class="divider"></li>
 <li><a href="/research/">Research</a></li>
 <li><a href="/talks/">Talks</a></li>
 <li><a href="/teaching/">Teaching</a></li>
 <li><a href="/music/">Music</a></li>
 <li class="dropdown">
   <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">More <span class="caret"></span></a>
   <ul class="dropdown-menu">
     <li><a href="/hyper-flop/">Hyper-Flop</a></li>
     <li role="separator" class="divider"></li>
     <li><a href="/pdfs/">PDFs & Talks</a></li>
     <li><a href="/agreg-dev/">Agregation de mathématique</a></li>
     <li role="separator" class="divider"></li>
     <li><a href="https://github.com/jeremycochoy/sednl" alt="SEDNL Github">SEDNL (Github)</a></li>
     <li><a href="http://sednl.zenol.fr" alt="Simple Event Driven Network Library">SEDNL</a></li>
           <li role="separator" class="divider"></li>
           <li><a href="/gb-doc">GameBoy Emulator Documentation</a></li>
   </ul>
 </li>
     </ul>
   </div><!--/.nav-collapse -->
 </div>
</nav>


    <div class="container">
      <div class="post">
  <h1 class="post-title">Le Haskell, un langage au label pure. Troisième partie.</h1>
  <span class="post-date">01 May 2013</span>
  <p>Et voici la troisième et dernière partie de notre découverte de ce joli langage. Au programme : des super foncteurs. D’abord des foncteurs applicatifs, puis des monades! Si vous rêviez de savoir pourquoi tant de gens s’enflamment devant ce langage, il est peut-être venue l’heure de la révélation.</p>

<p>La <a href="http://zenol.fr/site/blog/posts/haskell-pure-1/fr.htm" title="Le Haskell, un langage au label pure. Première partie.">première partie est ici</a>, <a href="http://zenol.fr/site/blog/posts/haskell-pure-2/fr.htm" title="Le Haskell, un langage au label pure. Seconde partie.">la seconde là</a>.</p>

<h2 id="foncteurs-applicatifs">Foncteurs applicatifs</h2>

<p>Les foncteurs applicatifs sont un enrichissement des foncteurs. C’est donc une classe, définie dans le module <code class="highlighter-rouge">Control.Applicative</code>, de la façon suivante :</p>
<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">class</span> <span class="p">(</span><span class="kt">Functor</span> <span class="n">f</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="kt">Applicative</span> <span class="n">f</span> <span class="kr">where</span>
   <span class="n">pure</span>  <span class="o">::</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">a</span>
   <span class="p">(</span><span class="o">&lt;*&gt;</span><span class="p">)</span> <span class="o">::</span> <span class="n">f</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">b</span>
</code></pre></div></div>

<p>Avec un type fonctoriel Fonc, on pouvais :</p>
<ul>
  <li>Prendre un élément de type <code class="highlighter-rouge">c</code> et le transformer en <code class="highlighter-rouge">Fonc c</code>, c’est à dire le “placer dans un contexte minimal”.</li>
  <li>Prendre une fonction de type <code class="highlighter-rouge">a-&gt;b</code> et la transformer en une fonction de type <code class="highlighter-rouge">Fonc a -&gt; Fonc b</code> grâce à <code class="highlighter-rouge">fmap</code>.</li>
</ul>

<p>Grace à un foncteur applicatif, on peut :</p>
<ul>
  <li>Prendre un élément de type <i>c</i> et le transformer en type <code class="highlighter-rouge">Fonc c</code>, cela se fait grâce à la fonction <code class="highlighter-rouge">pure :: (Applicative f) =&gt; c -&gt; f c</code>.</li>
  <li>Prendre une fonction dans un foncteur (ie un élément de type <code class="highlighter-rouge">Fonc (a-&gt;b)</code>) et l’appliquer à un élément de type <code class="highlighter-rouge">Fonc a</code> pour produire un <code class="highlighter-rouge">Fonc b</code>. L’opérateur permettant une telle chose est noté <code class="highlighter-rouge">&lt;*&gt; :: (Applicative f) =&gt; f (a -&gt; b) -&gt; f a -&gt; f b</code>.</li>
</ul>

<p>La seconde notion est plus générale, car si vous avez un constructeur de type <code class="highlighter-rouge">Fonc</code> qui est une instance de <code class="highlighter-rouge">Applicative</code> (La classe des foncteurs applicatifs), alors c’est un foncteur de la façon suivante :</p>
<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">instance</span> <span class="kt">Functor</span> <span class="kt">Fonc</span> <span class="kr">where</span>
   <span class="n">fmap</span> <span class="n">f</span> <span class="n">e</span> <span class="o">=</span> <span class="p">(</span><span class="n">pure</span> <span class="n">f</span><span class="p">)</span> <span class="o">&lt;*&gt;</span> <span class="n">e</span>
</code></pre></div></div>

<p>C’est à dire : Prenez f une fonction de type <code class="highlighter-rouge">a -&gt; b</code>, alors vous savez comment l’appliquer sur un <code class="highlighter-rouge">Fonc a</code>. Il suffit de la “placer” elle aussi dans un foncteur, pour se retrouver avec une “fonction dans un contexte” de type <code class="highlighter-rouge">Fonc (a-&gt;b)</code> à appliquer sur un “élément dans un contexte” de type <code class="highlighter-rouge">F a</code>.</p>

<p>C’est donc pour cela que l’on impose à tout foncteur applicatif d’être d’abord une instance de <code class="highlighter-rouge">Functor</code>, et que vous avez la contraire <code class="highlighter-rouge">"Functor f"</code> dans la définition de la classe <code class="highlighter-rouge">Applicative</code>.</p>

<h3 id="on-se-prépare-au-grand-saut-avec-maybe">On se prépare au grand saut avec <code class="highlighter-rouge">Maybe</code></h3>

<p>Tout ceci est très abstrait, alors regardons ce que cela donne avec un exemple simple. On considère <code class="highlighter-rouge">Maybe</code> qui est une instance de <code class="highlighter-rouge">Applicative</code> de la façon suivante :</p>
<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">instance</span> <span class="kt">Applicative</span> <span class="kt">Maybe</span> <span class="kr">where</span>
   <span class="n">pure</span> <span class="o">=</span> <span class="kt">Just</span>
   <span class="p">(</span><span class="kt">Just</span> <span class="n">f</span><span class="p">)</span> <span class="o">&lt;*&gt;</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="kt">Just</span> <span class="p">(</span><span class="n">f</span> <span class="n">x</span><span class="p">)</span>
   <span class="kr">_</span>        <span class="o">&lt;*&gt;</span> <span class="kr">_</span>        <span class="o">=</span> <span class="kt">Nothing</span>
</code></pre></div></div>

<p>La méthode <code class="highlighter-rouge">pure</code> prend un <code class="highlighter-rouge">truc :: a</code> et le place dans un <code class="highlighter-rouge">Maybe a</code> par <code class="highlighter-rouge">Just truc</code>. C’est la façon la plus intuitive de placer notre <code class="highlighter-rouge">truc</code> dans un <code class="highlighter-rouge">Maybe</code>, sans perdre d’information. L’opérateur <code class="highlighter-rouge">&lt;*&gt;</code> se contente lui de récupérer la fonction à sa gauche, la valeur à sa droite, d’effectuer le calcul (l’application de f à x) puis de placer le résultat dans un contexte minimal en utilisant le constructeur <code class="highlighter-rouge">Just</code>. La dernière ligne s’occupe des cas où il manque la fonction, l’argument, ou bien les deux. Dans ces trois cas, on ne peut effectuer le calcul, et l’on ne peut donc pas produire de résultat.</p>

<p>Comme dit plus haut, si l’on vais une fonction qui prend la racine carré (<code class="highlighter-rouge">sqrt :: Int</code>) d’un entier, et “peut-être un nombre” (un <code class="highlighter-rouge">v :: Maybe Int</code>), on pouvais mapper notre fonction avec la ligne <code class="highlighter-rouge">fmap sqrt v</code>. Avec un foncteur applicatif, on peut aussi écrire :</p>
<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">resultat</span>  <span class="o">=</span> <span class="p">(</span><span class="n">pure</span> <span class="n">sqrt</span><span class="p">)</span> <span class="o">&lt;*&gt;</span> <span class="n">v</span>
</code></pre></div></div>

<p>Mais alors, quel est l’intérêt des foncteurs applicatifs? Un premier exemple est l’application d’une fonction prenant trois entiers à trois “peut-être un entier”.</p>
<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">--Ici, v1, v2 et v3 sont de type Maybe Int.</span>
<span class="c1">--Si vous voulez savoir d'où il viennent, disons que ce sont le résultat</span>
<span class="c1">--de la lecture d'une chaine de caractère et de tentative de conversion de</span>
<span class="c1">--la chaine en nombres. Si c'était possible, alors on a des valeurs. Sinon, on auras "Nothing".</span>

<span class="c1">--On a une superbe fonction :</span>
<span class="n">deepThought</span> <span class="o">::</span> <span class="kt">Int</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="o">-&gt;</span> <span class="kt">Answer</span>

<span class="c1">--Et on veut l'appliquer à v1, v2, v3.</span>
<span class="c1">--Si l'on essaye avec un foncteur :</span>
<span class="n">premiereApplication</span> <span class="o">::</span> <span class="kt">Maybe</span> <span class="p">(</span><span class="kt">Int</span><span class="o">-&gt;</span><span class="kt">Int</span><span class="o">-&gt;</span><span class="kt">Answer</span><span class="p">)</span>
<span class="n">premiereApplication</span> <span class="o">=</span> <span class="n">fmap</span> <span class="n">deepThought</span> <span class="n">v1</span>

<span class="c1">--Maintenant, on est bloquer, on ne sais pas appliquer</span>
<span class="c1">-- une fonction qui se trouve dans un maybe...</span>
<span class="o">--...</span> <span class="err">à</span> <span class="n">moins</span> <span class="n">d'utiliser</span> <span class="o">&lt;*&gt;</span> <span class="o">:</span><span class="p">)</span>
<span class="n">secondeApplication</span> <span class="o">::</span> <span class="kt">Maybe</span> <span class="p">(</span><span class="kt">Int</span> <span class="o">-&gt;</span> <span class="kt">Answer</span><span class="p">)</span>
<span class="n">secondeApplication</span> <span class="o">=</span> <span class="n">premiereApplication</span> <span class="o">&lt;*&gt;</span> <span class="n">v2</span>
<span class="n">derniereApplication</span> <span class="o">::</span> <span class="kt">Maybe</span> <span class="kt">Answer</span>
<span class="n">derniereApplication</span> <span class="o">=</span> <span class="n">secondeApplication</span> <span class="o">&lt;*&gt;</span> <span class="n">v3</span>

<span class="c1">--En fait, on aurait pu d'abord placer la fonction dans un Just,</span>
<span class="c1">-- puis appliquer v1, v2 et v3 avec &lt;*&gt; :</span>
<span class="n">toutEnUn</span> <span class="o">::</span> <span class="kt">Maybe</span> <span class="kt">Answer</span>
<span class="n">toutEnUn</span> <span class="o">=</span> <span class="p">(</span><span class="n">pure</span> <span class="n">deepThought</span><span class="p">)</span> <span class="o">&lt;*&gt;</span> <span class="n">v1</span> <span class="o">&lt;*&gt;</span> <span class="n">v2</span> <span class="o">&lt;*&gt;</span> <span class="n">v3</span>

<span class="c1">--Et pour finir, sachez qu'il existe un petit sucre syntaxique</span>
<span class="c1">-- pour "(pure f) &lt;*&gt; x" ; l'opérateur &lt;$&gt; :</span>
<span class="n">toutEnUn</span> <span class="o">::</span> <span class="kt">Maybe</span> <span class="kt">Answer</span>
<span class="n">toutEnUn'</span> <span class="o">=</span> <span class="n">deepThought</span> <span class="o">&lt;$&gt;</span> <span class="n">v1</span> <span class="o">&lt;*&gt;</span> <span class="n">v2</span> <span class="o">&lt;*&gt;</span> <span class="n">v3</span>
</code></pre></div></div>

<p>Mais parce que le haskell détient bien plus de P-P-P-P-Puissance, intéressons nous à une autre instance de <code class="highlighter-rouge">Applicative</code> : Les listes.</p>

<h3 id="premier-plongeon-avec-les-listes">Premier plongeon avec les listes</h3>

<p>Comme nous l’avions vu la dernière fois, les listes sont un excellent exemple de foncteur. Mais pouvons nous en faire des foncteurs applicatifs? Il est facile de placer une valeur dans un contexte minimal : on définira <code class="highlighter-rouge">pure a = [a]</code>. En fait, il nous faudrait répondre à la question suivante : Si l’on a une liste de fonction <code class="highlighter-rouge">[f1, f2, f3]</code> et de valeurs <code class="highlighter-rouge">[2, 3, 4]</code>, comment définir l’opérateur <code class="highlighter-rouge">&lt;*&gt;</code> ?</p>

<p>La solution retenue par haskell est on ne peut plus simple : on applique toutes les fonctions à toutes les valeurs. Voici la définition de l’instance :</p>
<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">instance</span> <span class="kt">Applicative</span> <span class="kt">[]</span> <span class="kr">where</span>
    <span class="n">pure</span> <span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span>
    <span class="n">fs</span> <span class="o">&lt;*&gt;</span> <span class="n">xs</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span> <span class="n">x</span> <span class="o">|</span> <span class="n">f</span> <span class="o">&lt;-</span> <span class="n">fs</span><span class="p">,</span> <span class="n">x</span> <span class="o">&lt;-</span> <span class="n">xs</span><span class="p">]</span>
</code></pre></div></div>

<p>Cela donne une façon très facile d’effectuer de nombreux calculs simultanément ; vous disposez d’un ensemble de valeurs, et d’un ensemble de fonctions. Vous voulez connaître TOUS les résultats possible. Il suffit alors d’appliquer la liste des fonctions sur la liste des valeurs avec l’opérateur <code class="highlighter-rouge">&lt;*&gt;</code>. Un exemple, en partie tiré de_Learn You Haskell for Great Good_ est le problème du parcoure d’un cavalier. Un cavalier est situé sur une case d’un échiquier infini, et vous voulez connaître toute les positions où il peut se trouver après 5 coups. Il suffit décrire une fonction par déplacement possible, puis de construire une liste de ces fonctions,  disons <code class="highlighter-rouge">[u1, u2, l1, l2, r1, r2, d1, d2]</code>. On applique cette liste à la position d’origine placée dans un contexte : <code class="highlighter-rouge">[(x, y)]</code> (ou encore <code class="highlighter-rouge">pure (x, y)</code>). La solution est donné par l’application répété de notre liste de fonction, comme le montre le code suivant.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">u1</span> <span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">l</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span><span class="n">c</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="n">u2</span> <span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">l</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span><span class="n">c</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="n">d1</span> <span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">l</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="n">c</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="n">d2</span> <span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">l</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="n">c</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="n">l1</span> <span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">l</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">c</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
<span class="n">l2</span> <span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">l</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">c</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
<span class="n">r1</span> <span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">l</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">c</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span>
<span class="n">r2</span> <span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">l</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">c</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span>

<span class="n">fctListe</span> <span class="o">=</span> <span class="p">[</span><span class="n">u1</span><span class="p">,</span> <span class="n">u2</span><span class="p">,</span> <span class="n">d1</span><span class="p">,</span> <span class="n">d2</span><span class="p">,</span> <span class="n">l1</span><span class="p">,</span> <span class="n">l2</span><span class="p">,</span> <span class="n">r1</span><span class="p">,</span> <span class="n">r2</span><span class="p">]</span>
<span class="n">origine</span> <span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="o">=</span> <span class="p">[(</span><span class="n">l</span><span class="p">,</span><span class="n">c</span><span class="p">)]</span>

<span class="n">etapeSuivante</span> <span class="n">position</span> <span class="o">=</span> <span class="n">fctListe</span> <span class="o">&lt;*&gt;</span> <span class="n">position</span>

<span class="n">solution</span> <span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="o">=</span> <span class="n">etapeSuivante</span> <span class="o">.</span> <span class="n">etapeSuivante</span> <span class="o">.</span> <span class="n">etapeSuivante</span> <span class="o">.</span> <span class="n">etapeSuivante</span> <span class="o">.</span> <span class="n">etapeSuivante</span> <span class="o">$</span> <span class="n">origine</span> <span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="en-apnée--le-foncteur---r-">En apnée : le foncteur <code class="highlighter-rouge">(-&gt;) r</code> !</h3>

<p>On les avais cacher lors de la discussion des foncteurs, car ils sont difficile à cerné. Leur intérêt n’est pas évident au premier abord et leur construction est quelque peu… surprenante. Mais puisqu’ils sont utile comme foncteur applicatif, parlons en! Si la partie la plus abstraite vous échappe, aucune raison de vous inquiéter, l’idée est de survoler les notions pour avoir un aperçu, éveiller la curiosité et inciter à lire des livres/articles qui expliquent en détaille ce qui n’est ici que mentionner. Si tout cela vous intéresse, sautez à la section “Foncteurs applicatifs” de Learn You Haskell for Great Good!</p>

<p>L’opérateur <code class="highlighter-rouge">-&gt;</code> est un constructeur de type, à deux arguments. Vous lui donnez deux types, <code class="highlighter-rouge">a</code> et <code class="highlighter-rouge">b</code>, et il vous construiras le type “prend du a et retourne du b”. On peut donc écrire <code class="highlighter-rouge">f :: a -&gt; b</code> ou encore ` f :: (-&gt;) a b<code class="highlighter-rouge">. Que signifie alors </code>(-&gt;) r<code class="highlighter-rouge"> ? On parle d'un constructeur de type à un argument qui, si vous lui donnez un type </code>a<code class="highlighter-rouge">, désigneras alors les fonctions de type </code>a -&gt; r<code class="highlighter-rouge">. Si </code>r<code class="highlighter-rouge"> désigne un type, on peut alors faire de </code>(-&gt;) r<code class="highlighter-rouge"> une instance de </code>Functor<code class="highlighter-rouge"> où mapper une fonction </code>f<code class="highlighter-rouge"> de type </code>a-&gt;b<code class="highlighter-rouge"> sur une fonction </code>g<code class="highlighter-rouge"> de type </code>a -&gt; r<code class="highlighter-rouge"> signifie appliquer </code>f<code class="highlighter-rouge"> au résultat de l'évaluation de la fonction </code>g`. Plus précisément :</p>
<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">instance</span> <span class="kt">Functor</span> <span class="p">((</span><span class="o">-&gt;</span><span class="p">)</span> <span class="n">r</span><span class="p">)</span> <span class="kr">where</span>
    <span class="n">fmap</span> <span class="n">f</span> <span class="n">g</span> <span class="o">=</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="p">(</span><span class="n">g</span> <span class="n">x</span><span class="p">))</span>
</code></pre></div></div>

<p>On peut se demander l’intérêt, puisque <code class="highlighter-rouge">(fmap f g) 42</code> se simplifie en <code class="highlighter-rouge">f . g $ 42</code> qui est, à priori, bien plus lisible. Outre sa fantastique capacité à mettre votre esprit à rude épreuve, ce changement de point de vue devient très intéressant avec la classe <code class="highlighter-rouge">Applicative</code>, puisqu’il donne la possibilité d’avoir un ensemble de paramètres.</p>

<p>Un exemple commenté :</p>
<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">--Notre type "paramètre". On aurais pu construire une sorte de grosse structure</span>
<span class="c1">-- avec diverses informations.</span>
<span class="c1">--Dans cette exemple, on se contenteras d'un nombre.</span>
<span class="kr">type</span> <span class="kt">Param</span> <span class="o">=</span> <span class="kt">Int</span>

<span class="n">unEntier</span> <span class="o">::</span> <span class="kt">Param</span> <span class="o">-&gt;</span> <span class="kt">Int</span>
<span class="n">unEntier</span> <span class="o">=</span> <span class="n">pure</span> <span class="mi">5</span>

<span class="n">unAutreEntier</span> <span class="o">::</span> <span class="kt">Param</span> <span class="o">-&gt;</span> <span class="kt">Int</span>
<span class="n">unAutreEntier</span> <span class="n">param</span> <span class="o">=</span> <span class="mi">5</span> <span class="o">+</span> <span class="n">param</span>

<span class="n">uneFonction</span> <span class="o">::</span> <span class="kt">Param</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="o">-</span> <span class="o">&gt;</span> <span class="kt">String</span>
<span class="n">uneFonction</span> <span class="n">param</span> <span class="n">arg</span> <span class="o">=</span> <span class="n">show</span> <span class="p">(</span><span class="n">arg</span> <span class="o">+</span> <span class="n">param</span><span class="p">)</span>

<span class="n">somme</span> <span class="o">=</span> <span class="n">pure</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="o">&lt;$&gt;</span> <span class="n">unEntier</span> <span class="o">&lt;*&gt;</span> <span class="n">unAutreEntier</span>
<span class="n">affichage</span> <span class="o">=</span> <span class="n">uneFonction</span> <span class="o">&lt;*&gt;</span> <span class="n">somme</span>

<span class="c1">--Vaut 94 :</span>
<span class="n">evaluationDansUnCOntexte</span> <span class="o">=</span> <span class="n">affichage</span> <span class="mi">42</span>
</code></pre></div></div>

<h3 id="quelques-règles-que-nul-ne-doit-ignorer">Quelques règles que nul ne doit ignorer</h3>

<p>Comme on dit, <code class="highlighter-rouge">dura lex, sed lex</code>. Les foncteurs devaient respecter certaines règles, et il en est de même des foncteurs applicatifs. Une fois habitué aux foncteurs applicatifs, ces règles semblent découler du bon sens. Ce sont des invariants que DOIVENT respecter vos instances d’<code class="highlighter-rouge">Applicative</code>. Si vous ne les respectez pas, c’est que ce que vous voulez faire n’est pas un foncteur applicatif, et n’a donc aucune raison d’être instance d’<code class="highlighter-rouge">Applicative</code>.</p>

<p>Sans trop rentrer dans les détails, les voici, brièvement commentés :</p>
<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- Neutre :</span>
<span class="n">pure</span> <span class="n">id</span> <span class="o">&lt;*&gt;</span> <span class="n">v</span> <span class="o">=</span> <span class="n">v</span>
<span class="c1">--Cela signifie qu'appliquer la fonction identité</span>
<span class="c1">-- (id = (\x -&gt; x) ) a un élément v via &lt;*&gt; le laisse inchangé.</span>
<span class="c1">--C'est une sorte de "neutre à gauche".</span>

<span class="c1">-- Composition :</span>
<span class="n">pure</span> <span class="p">(</span><span class="o">.</span><span class="p">)</span> <span class="o">&lt;*&gt;</span> <span class="n">u</span> <span class="o">&lt;*&gt;</span> <span class="n">v</span> <span class="o">&lt;*&gt;</span> <span class="n">w</span> <span class="o">=</span> <span class="n">u</span> <span class="o">&lt;*&gt;</span> <span class="p">(</span><span class="n">v</span> <span class="o">&lt;*&gt;</span> <span class="n">w</span><span class="p">)</span>
<span class="c1">--Cela signifie que composer les fonctions à l'intérieur de u et v</span>
<span class="c1">-- via l'opérateur .  (C'est la partie pure (.) &lt;*&gt; u &lt;*&gt; v) revient à calculer u sur le résultat de v.</span>
<span class="c1">--Comme on compare deux fonctions sur leur valeur, et que l'on parle de résultat, on doit introduire</span>
<span class="c1">-- un certain mister w, et on vérifie que quelque soit ce w, on a bien que u calculer sur v calculé sur w donne bien le même résultat que la composé (pure (.) &lt;*&gt; u &lt;*&gt; v) calculé sur w.</span>

<span class="c1">-- Morphisme :</span>
<span class="n">pure</span> <span class="n">f</span> <span class="o">&lt;*&gt;</span> <span class="n">pure</span> <span class="n">x</span> <span class="o">=</span> <span class="n">pure</span> <span class="p">(</span><span class="n">f</span> <span class="n">x</span><span class="p">)</span>
<span class="c1">--Cette égalité garanti que : placer f dans un contexte minimal, placer x dans un contexte</span>
<span class="c1">-- minimal, puis "mouliner" donne le même résultat que f x placé dans un contexte minimal. En quelque sorte,</span>
<span class="c1">-- on transforme l'opérateur $ :: (a-&gt;b) -&gt; a -&gt; b en l'opérateur &lt;*&gt; :: f (a-&gt;b) -&gt; f a -&gt; f b.</span>

<span class="c1">-- ' Échange '</span>
<span class="n">u</span> <span class="o">&lt;*&gt;</span> <span class="n">pure</span> <span class="n">y</span> <span class="o">=</span> <span class="n">pure</span> <span class="p">(</span><span class="o">$</span> <span class="n">y</span><span class="p">)</span> <span class="o">&lt;*&gt;</span> <span class="n">u</span>

<span class="c1">-- C'est une sorte de commutativité du pauvre. On ne peut pas vraiment échanger les arguments à droite et à gauche, car l'un est une fonction, l'autre une valeur. Mais on peut transformer une évaluation "f y" en "$ f y ", ce qui permet de changer l'ordre des arguments.</span>
</code></pre></div></div>

<h2 id="monades">Monades</h2>

<p>Les monades, c’est le cran au dessus. On ne veut plus seulement mapper des fonctions <code class="highlighter-rouge">f: a -&gt; b</code> à l’intérieur d’un <code class="highlighter-rouge">Fonc a</code>, ni seulement évaluer des fonctions <code class="highlighter-rouge">Fonc (a -&gt; b)</code> dans un contexte <code class="highlighter-rouge">F a</code>. Maintenant, on dispose de fonctions qui travaillent sur une valeur, et produisent un résultat dans un contexte. Des fonctions de type <code class="highlighter-rouge">f :: a -&gt; Fonc b</code>. Si l’on essayais de les mapper comme des foncteurs sur un <code class="highlighter-rouge">Fonc a</code>, on se retrouverais avec du <code class="highlighter-rouge">Fonc (Fonc b)</code>, ce qui n’est pas du tout ce que l’on veut. Il nous faut donc une fonction capable de recoller ces “Fonc Fonc” en “Fonc”. C’est ce que fournisse les monades.</p>

<p>Tout de suite, la classe monade :</p>
<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">class</span> <span class="kt">Monad</span> <span class="n">m</span> <span class="kr">where</span>
  <span class="p">(</span><span class="o">&gt;&gt;=</span><span class="p">)</span> <span class="o">::</span> <span class="n">m</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">b</span> <span class="c1">-- On l’appelle aussi "bind"</span>
  <span class="p">(</span><span class="o">&gt;&gt;</span><span class="p">)</span> <span class="o">::</span> <span class="n">m</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">b</span> <span class="c1">-- C'est une sorte d'opérateur de concaténation.</span>
<span class="c1">-- &gt;&gt; Ignore le premier argument et renvoi la valeur du second.</span>
<span class="c1">-- On vera plus tard qu'en fait, c'est extrêmement utile, avec la monade IO.</span>
  <span class="n">return</span> <span class="o">::</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">a</span> <span class="c1">-- C'est notre bon vieux pure, sous un autre nom.</span>
  <span class="n">fail</span> <span class="o">::</span> <span class="kt">String</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">a</span> <span class="c1">-- On ne l'utiliseras pas, et on en parleras pas.</span>
<span class="c1">-- Sachez toute fois que ca renvoi moralement un "contexte sans information".</span>
<span class="c1">-- Par exemple une liste vide, un Nothing, etc.</span>
</code></pre></div></div>

<p>Les deux opérateurs principaux sont <code class="highlighter-rouge">bind</code> et <code class="highlighter-rouge">return</code>. Voyons comment on pourrait, partant d’une monade, la faire instance d’Applicative :</p>
<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">instance</span> <span class="kt">Monade</span> <span class="kt">Fonc</span> <span class="kr">where</span>
  <span class="n">pure</span> <span class="o">=</span> <span class="n">return</span>
  <span class="c1">-- L'astuce est de construire une fonction f' :: (a -&gt; m b) que l'on puisse utiliser à la place de f.</span>
  <span class="c1">-- On la construit grâce à "pure . f".</span>
  <span class="c1">-- Mais comme f est elle même dans un contexte, il faut faire cette transformation dans le contexte.</span>
  <span class="n">mf</span> <span class="p">(</span><span class="o">&lt;*&gt;</span><span class="p">)</span> <span class="n">mv</span> <span class="o">=</span> <span class="n">mf</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\</span><span class="n">f</span> <span class="o">-&gt;</span> <span class="n">mv</span> <span class="o">&gt;&gt;=</span> <span class="n">return</span><span class="o">.</span><span class="n">f</span><span class="p">)</span>
<span class="c1">-- On donne mf à manger a la grosse fonction de droite. La grosse fonction de droite récupère la fonction f, la transforme en une f' par return.f. On donne donc la valeur v contenue dans mv à manger a la fonction f' grâce à &gt;&gt;=.</span>
</code></pre></div></div>

<p>Bon, si vous avez suivi jusque là, soit vous connaissez déjà le haskell, soit vous êtes des sur-hommes (ou des matheux, auquel cas je ne peux plus rien pour vous). Voyons en pratique ce qu’apportent les monades, et pourquoi est-ce que bien utilisé, elles offres une nouvelle façon de résoudre certains problèmes bien connu du monde impératif.</p>

<h3 id="être-ou-ne-pas-être">Être ou ne pas être?</h3>

<p>Dans un “vrai” programme, on n’a pas toujours une valeur a retourner pour une fonction. Que faire si l’on demande le premier élément d’une liste vide? Et si jamais on veut convertir une chaine en un nombre, qui par malheur contient le prénom de votre animal de compagnie? En bref, comment gérer une erreur correspondant à l’absence d’un résultat?</p>

<p>La réponse est la monade maybe. Commençons par des fonctions qui renvoient peut-être une valeur :</p>
<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">maybeHead</span> <span class="o">::</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="kt">Maybe</span> <span class="n">a</span>
<span class="n">maybeHead</span> <span class="kt">[]</span> <span class="o">=</span> <span class="kt">Nothing</span>
<span class="n">maybeHead</span> <span class="p">(</span><span class="n">head</span> <span class="o">:</span> <span class="n">tail</span><span class="p">)</span> <span class="o">=</span> <span class="kt">Just</span> <span class="n">head</span>

<span class="n">maybeList</span> <span class="o">::</span> <span class="p">(</span><span class="kt">Int</span><span class="p">,</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Maybe</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span>
<span class="n">maybeList</span> <span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">)</span> <span class="o">=</span> <span class="kr">if</span> <span class="n">first</span> <span class="o">&lt;=</span> <span class="n">last</span> <span class="kr">then</span> <span class="p">[</span><span class="n">first</span><span class="o">..</span><span class="n">last</span><span class="p">]</span> <span class="kr">else</span> <span class="kt">Nothing</span>

<span class="n">maybeRange</span> <span class="o">::</span> <span class="kt">Bool</span> <span class="o">-&gt;</span> <span class="kt">Maybe</span> <span class="p">(</span><span class="kt">Int</span><span class="p">,</span> <span class="kt">Int</span><span class="p">)</span>
<span class="n">maybeRange</span> <span class="kt">False</span> <span class="o">=</span> <span class="kt">Nothing</span>
<span class="n">maybeRange</span> <span class="kt">True</span> <span class="o">=</span> <span class="p">(</span><span class="mi">23</span><span class="p">,</span> <span class="mi">42</span><span class="p">)</span>
</code></pre></div></div>

<p>On voudrais maintenant récupérer le premier élément de la liste pour les valeur donné par maybeRange, si la liste existe, bien sure. C’est la que les monades interviennent! Grâce au monades, on peut composer les deux fonctions, bien qu’un <code class="highlighter-rouge">Maybe [Int]</code> ne soit pas un <code class="highlighter-rouge">[Int]</code>.</p>
<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">resultat</span> <span class="o">::</span> <span class="kt">Maybe</span> <span class="kt">Int</span>
<span class="n">resultat</span> <span class="n">choice</span> <span class="o">=</span> <span class="n">maybeRange</span> <span class="n">choice</span> <span class="o">&gt;&gt;=</span> <span class="n">maybeList</span> <span class="o">&gt;&gt;=</span> <span class="n">maybeHead</span>
</code></pre></div></div>

<p>Si l’une des étapes ne produit pas de résultat (un <code class="highlighter-rouge">Nothing</code>), alors l’absence de résultat seras propagé et on obtiendras un <code class="highlighter-rouge">Nothing</code>.</p>

<p>Cette méthode a de nombreux avantages par rapport aux deux vielles solutions bien connues :
1) Le “code d’erreur”, c’est à dire placer nullptr quand on pointeur n’existe pas, ou encore “-1” ou 0 pour signaler une erreur. L’inconvénient de cette méthode est d’obliger le développeur à vérifier chacune des valeurs de retour avec un if, généralement pour sortir de la fonction, souvent en retournant un nouveau code d’erreur pour signaler que le résultat produit n’est pas “vraiment” un résultat, mais une absence de résultat.</p>

<p>L’utilisation de la monade Maybe permet d’éviter ces testes répété. Si une seul des fonctions ne peut pas fournir de résultat, alors les applications suivantes seront toute ignoré et, bien entendu, ces fonctions ne seront pas évaluées, donc pas de coût en temps de calcul.</p>

<p>2) Les exceptions. Cela consiste à interrompre l’exécution normale du programme pour remonter a travers toute la pile d’appels, en espérant que quelqu’un seras assez gentil pour s’occuper de cette erreur. Cela a un coût en terme de performances, et doit être réserver pour les évènements exceptionnels. L’impossibilité de produire un résultat est rarement exceptionnel, c’est plutôt chose commune.</p>

<p>Le chaînage de monade Maybe a l’avantage de ne pas déclencher un erreurs qui pourrait se perdre et aller jusqu’à interrompre le programme. Que les valeurs soient présente ou non, le comportement est toujours “simple” à prédire. Et plus un code est simple, moins il y a de risque qu’une erreurs s’introduisse à l’insu du développeur.</p>

<p>En règle générale, dès que le résultat peut ne pas être fournit, vous devriez utiliser la monade Maybe. Si parfois une certaine fonction f que vous voulez chaîner produit toujours un résultat, alors vous pouvez la placer au milieu d’une chaine de <code class="highlighter-rouge">&gt;&gt;=</code> en écrivant <code class="highlighter-rouge">return.f</code>. Vous pouvez aussi une bonne vielle <code class="highlighter-rouge">fmap</code>, car toute les monades sont des foncteurs applicatifs, donc des foncteurs.</p>

<p>Nb : Peut-être avez vous besoin de conserver une information sur l’origine de l’erreur. Ceci est possible grâce à la monade <code class="highlighter-rouge">Either a</code> (souvent on utilise <code class="highlighter-rouge">Either String</code> pour stocker un message).</p>

<p>Pour finir, voici l’instance de cette monade :</p>
<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">instance</span> <span class="kt">Monad</span> <span class="kt">Maybe</span> <span class="kr">where</span>  
        <span class="n">return</span> <span class="n">x</span> <span class="o">=</span> <span class="kt">Just</span> <span class="n">x</span>  
        <span class="kt">Nothing</span> <span class="o">&gt;&gt;=</span> <span class="n">f</span> <span class="o">=</span> <span class="kt">Nothing</span>  
        <span class="kt">Just</span> <span class="n">x</span> <span class="o">&gt;&gt;=</span> <span class="n">f</span>  <span class="o">=</span> <span class="n">f</span> <span class="n">x</span>  
        <span class="n">fail</span> <span class="kr">_</span> <span class="o">=</span> <span class="kt">Nothing</span>  
</code></pre></div></div>

<h3 id="un-calcul-pas-très-déterministe">Un calcul pas très déterministe</h3>

<p>Nous avions vu comment les listes comme foncteurs applicatifs permettent de résoudre élégamment la question du déplacement d’un cavalier. Mais dans un échiquier fini, on ne savais pas trop comment gérer les bords.</p>

<p>Les listes, vu comme monade, nous permettent de combiner des fonctions de type <code class="highlighter-rouge">a -&gt; [b]</code>. L’idée est que vous disposez de diverse fonctions qui prennent une valeur, et produise divers résultats possible. Vous voulez alors appliquer des fonctions sur chacun de ces résultats. On peut donc parler de calcul non-déterministe : une valeur donne plusieurs résultats possible.</p>

<p>On peut donc réaliser un remake du cavalier, en se servant de ce calcul non déterministe, puisqu’à partir d’une position, on a diverses positions possibles</p>
<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">--Quelques types pour plus de lisibilité,</span>
<span class="c1">-- histoire de rappeler que les types sont</span>
<span class="c1">-- aussi là pour fournir des informations sémantiques.</span>
<span class="kr">type</span> <span class="kt">Ligne</span> <span class="o">=</span> <span class="kt">Int</span>
<span class="kr">type</span> <span class="kt">Collone</span> <span class="o">=</span> <span class="kt">Int</span>
<span class="kr">type</span> <span class="kt">Position</span> <span class="o">=</span> <span class="p">(</span><span class="kt">Ligne</span><span class="p">,</span> <span class="kt">Collone</span><span class="p">)</span>

<span class="c1">--Fonction utilisé pour ne garder que les positions dans l'échiquier</span>
<span class="n">dansLechiquier</span> <span class="o">::</span> <span class="kt">Position</span> <span class="o">-&gt;</span> <span class="kt">Bool</span>
<span class="n">dansLechiquier</span> <span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="o">=</span> <span class="n">l</span> <span class="p">`</span><span class="n">elem</span><span class="p">`</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">8</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">c</span> <span class="p">`</span><span class="n">elem</span><span class="p">`</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">8</span><span class="p">]</span>

<span class="c1">--Produit une liste des positions possibles</span>
<span class="n">deplacerCavalier</span> <span class="o">::</span> <span class="kt">Position</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="kt">Position</span><span class="p">]</span>
<span class="n">deplacerCavalier</span> <span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="o">=</span> <span class="n">filter</span> <span class="n">dansLechiquier</span> <span class="n">liste</span>
  <span class="kr">where</span> <span class="n">liste</span> <span class="o">=</span> <span class="p">[(</span><span class="n">l</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span><span class="n">c</span><span class="o">-</span><span class="mi">1</span><span class="p">),(</span><span class="n">l</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span><span class="n">c</span><span class="o">+</span><span class="mi">1</span><span class="p">),(</span><span class="n">l</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="n">c</span><span class="o">-</span><span class="mi">1</span><span class="p">),(</span><span class="n">l</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="n">c</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> 
                <span class="p">,(</span><span class="n">l</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">c</span><span class="o">-</span><span class="mi">2</span><span class="p">),(</span><span class="n">l</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">c</span><span class="o">+</span><span class="mi">2</span><span class="p">),(</span><span class="n">l</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">c</span><span class="o">-</span><span class="mi">2</span><span class="p">),(</span><span class="n">l</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">c</span><span class="o">+</span><span class="mi">2</span><span class="p">)]</span>

<span class="c1">--Donne la liste des positions possible du cavalier, partant de (4, 5), et après trois déplacements.</span>
<span class="n">resultat</span> <span class="o">=</span> <span class="n">return</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span> <span class="o">&gt;&gt;=</span> <span class="n">deplacerCavalier</span> <span class="o">&gt;&gt;=</span> <span class="n">deplacerCavalier</span> <span class="o">&gt;&gt;=</span> <span class="n">deplacerCavalier</span>
</code></pre></div></div>

<p>En fait, une autre façon de faire serai de mapper la fonction <code class="highlighter-rouge">deplacerCavalier</code> dans la liste de positions, produisant un <code class="highlighter-rouge">[[Position]]</code>, puis d’appeler <code class="highlighter-rouge">concat</code> sur cette liste, la recollant en une <code class="highlighter-rouge">[Position]</code>. C’est d’ailleurs de cette façon qu’est implémenté l’opérateur <code class="highlighter-rouge">&gt;&gt;=</code> !</p>

<p>L’utilisation des listes sous leur forme de monade n’est pas limité à cette exemple. Je peux mentionner un second cas qui vous paraîtras peut-être plus concret. Disons que vous voulez enregistrer une image, et que vous disposez d’une fonction qui vous donne les couleurs r, g, b, a sous la forme d’une liste de nombres, c’est à dire <code class="highlighter-rouge">getPixel (x, y) :: [Word8]</code> (Word8 est un nombre codé sur 8 bits). Sachant que pour enregistrer l’image, vous devez fournir un tableau, qui peut être très facilement construit à partir de la liste des valeurs qu’il vas contenir. (Le compilateur est très malins, et le programme compilé ne s’amusera pas à produire une liste, la construire en mémoire, puis la placer dans le tableau. Pas d’inquiétude, le compilateur est très douer à ce niveau.)
La monade <code class="highlighter-rouge">[]</code> permet d’écrire en une ligne, de façon très élégante, la création d’un tableau où les valeurs sont bien la succession des valeurs de <code class="highlighter-rouge">getPixel</code> calculé à chaque coordonné. Bien sur, on aurais pu utiliser <code class="highlighter-rouge">concat</code> et <code class="highlighter-rouge">map</code>, mais c’est justement ce que fait l’opérateur <code class="highlighter-rouge">&gt;&gt;=</code>. Tout ça pour dire que les listes vue comme monade ne sont pas un gadget, mais bien un outil utile à l’implémentation d’applications de la “vie de tout les jouers”.</p>

<p>Voici la définition de l’instance pour les curieux :</p>
<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">instance</span> <span class="kt">Monad</span> <span class="kt">[]</span> <span class="kr">where</span>  
    <span class="n">return</span> <span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span>  
    <span class="n">xs</span> <span class="o">&gt;&gt;=</span> <span class="n">f</span> <span class="o">=</span> <span class="n">concat</span> <span class="p">(</span><span class="n">map</span> <span class="n">f</span> <span class="n">xs</span><span class="p">)</span>  
    <span class="n">fail</span> <span class="kr">_</span> <span class="o">=</span> <span class="kt">[]</span>
</code></pre></div></div>

<h3 id="dou-doo-do-cest-le-goût">Dou? Doo? Do, c’est le goût!</h3>

<p>La notation do est une sorte de super sucre syntaxique. Seulement, les monades sont tellement amère que vous aurez vraiment besoin de ce sucre, je vous l’assure.
La notation do permet décrire facilement le chaînage d’actions, et le fait de récupérer des valeurs dans un contexte.</p>

<p>Considérons l’exemple suivant tiré de Learn You Haskell for Great Good (Non, je ne suis pas encore sponsorisé par eux.) :</p>
<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">foo</span> <span class="o">::</span> <span class="kt">Maybe</span> <span class="kt">String</span>  
<span class="n">foo</span> <span class="o">=</span> <span class="kt">Just</span> <span class="mi">3</span>   <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="o">-&gt;</span> 
      <span class="kt">Just</span> <span class="s">"!"</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\</span><span class="n">y</span> <span class="o">-&gt;</span> 
      <span class="kt">Just</span> <span class="p">(</span><span class="n">show</span> <span class="n">x</span> <span class="o">++</span> <span class="n">y</span><span class="p">)))</span>
</code></pre></div></div>
<p>On récupère deux valeurs de monades à travers x et y, puis l’on place le résultat de show x ++ y dans un contexte. C’est lourd a écrire, demande l’imbrication de fonctions… Avec la notation do, cela évident :</p>
<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">foo</span> <span class="o">::</span> <span class="kt">Maybe</span> <span class="kt">String</span>  
<span class="n">foo</span> <span class="o">=</span> <span class="kr">do</span>  
        <span class="n">x</span> <span class="o">&lt;-</span> <span class="kt">Just</span> <span class="mi">3</span>  
        <span class="n">y</span> <span class="o">&lt;-</span> <span class="kt">Just</span> <span class="s">"!"</span>  
        <span class="kt">Just</span> <span class="p">(</span><span class="n">show</span> <span class="n">x</span> <span class="o">++</span> <span class="n">y</span><span class="p">)</span>  

<span class="c1">-- Ou encore :</span>
<span class="n">foo</span> <span class="o">::</span> <span class="kt">Maybe</span> <span class="kt">String</span>  
<span class="n">foo</span> <span class="o">=</span> <span class="kr">do</span>  
        <span class="n">x</span> <span class="o">&lt;-</span> <span class="kt">Just</span> <span class="mi">3</span>  
        <span class="n">y</span> <span class="o">&lt;-</span> <span class="kt">Just</span> <span class="s">"!"</span>  
        <span class="n">return</span> <span class="p">(</span><span class="n">show</span> <span class="n">x</span> <span class="o">++</span> <span class="n">y</span><span class="p">)</span>  
</code></pre></div></div>

<p>Dans les deux premières lignes, on récupère <code class="highlighter-rouge">x</code> et <code class="highlighter-rouge">y</code> depuis <code class="highlighter-rouge">Just 3</code> et <code class="highlighter-rouge">Just "!"</code>, puis on fait notre traitement.</p>

<p>Hey! Mais ça ressemble a des listes en compréhension tout ça! Reproduisons le même exercice mais avec des listes :</p>
<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">foo</span> <span class="o">::</span> <span class="kt">Maybe</span> <span class="kt">String</span>  
<span class="n">foo</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>   <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="o">-&gt;</span> 
          <span class="p">[</span><span class="s">"."</span><span class="p">,</span> <span class="s">"!"</span><span class="p">,</span> <span class="s">"?"</span><span class="p">]</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\</span><span class="n">y</span> <span class="o">-&gt;</span> 
          <span class="p">[</span><span class="n">show</span> <span class="n">x</span> <span class="o">++</span> <span class="n">y</span><span class="p">]))</span>
</code></pre></div></div>

<p>Le résultat produit est toute les façons de coller l’un des signes de ponctuation après l’un des nombres. C’est exactement la même chose que :</p>
<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">foo</span> <span class="o">::</span> <span class="kt">Maybe</span> <span class="kt">String</span>  
<span class="n">foo</span> <span class="o">=</span> <span class="kr">do</span>
          <span class="n">x</span> <span class="o">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
          <span class="n">y</span> <span class="o">&lt;-</span> <span class="p">[</span><span class="s">"."</span><span class="p">,</span> <span class="s">"!"</span><span class="p">,</span> <span class="s">"?"</span><span class="p">]</span>
          <span class="n">return</span> <span class="p">(</span><span class="n">show</span> <span class="n">x</span> <span class="o">++</span> <span class="n">y</span><span class="p">)</span>

<span class="c1">-- Ou encore :</span>
<span class="n">foo</span> <span class="o">=</span> <span class="p">[</span><span class="n">show</span> <span class="n">x</span> <span class="o">++</span> <span class="n">y</span> <span class="o">|</span> <span class="n">x</span> <span class="o">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">|</span> <span class="n">y</span> <span class="o">&lt;-</span> <span class="p">[</span><span class="s">"."</span><span class="p">,</span> <span class="s">"!"</span><span class="p">,</span> <span class="s">"?"</span><span class="p">]]</span>
</code></pre></div></div>

<p>Voilà donc l’origine des liste en compréhension! Et oui, il nous aura fallu arriver jusqu’ici pour pouvoir enfin expliquer ce que sont les liste en compréhension. C’est simplement un sucre syntaxique spécifique au liste d’un bloque do. C’est donc de la manipulation de monade que vous faites, à chaque fois que vous écrivez une liste en compréhension. Si c’est si pratique avec les listes, vous vous doutez bien que pouvoir le faire avec diverses structures (des arbres par exemple), est tout aussi pratique.</p>

<p>Vous vous demandez alors comment ajouter les conditions, comme dans <code class="highlighter-rouge">[x^2 | x &lt;- [1..20], x </code>mod<code class="highlighter-rouge"> 2 == 0]</code> ? Et bien vous pouvez utilisez la fonction <code class="highlighter-rouge">guard</code>, qui produiras une liste vide si la condition n’est pas vérifiée :</p>
<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">foo</span> <span class="o">=</span> <span class="kr">do</span>
      <span class="n">x</span> <span class="o">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">20</span><span class="p">]</span>
      <span class="n">guard</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="p">`</span><span class="n">mod</span><span class="p">`</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
      <span class="n">return</span> <span class="n">x</span><span class="o">^</span><span class="mi">2</span>
</code></pre></div></div>

<h3 id="le-retour-de-jafar-aussi-connu-sous-le-nom-de---r">Le retour de Jafar, aussi connu sous le nom de <code class="highlighter-rouge">(-&gt;) r</code>.</h3>

<p>Nous avions utilisé le foncteur applicatif <code class="highlighter-rouge">(-&gt;) r</code> pour représenter des calculs qui dépendent d’un contexte. On savais donc appliquer des fonctions <code class="highlighter-rouge">r -&gt; (a -&gt; b)</code> sur des valeurs <code class="highlighter-rouge">r -&gt; a</code>. Seulement, il est plus commun de partir d’une valeur, et produire un résultat qui dépend du contexte. On voudrais donc une monade, pour pouvoir combiner des fonctions de type <code class="highlighter-rouge">a -&gt; (r -&gt; b)</code> (Les parenthèses sont là pour faire ressortir que l’on considère (-&gt;) r comme un foncteur / une monade, mais bien sur facultatives).</p>

<p>Comme <code class="highlighter-rouge">(-&gt;) r</code> est l’une des monades les plus abstraites, regardons un exemple concret, où le contexte est la position d’une caméra dans un raytracer.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- On définit une caméra.</span>
<span class="c1">-- Une caméra contient la position depuis la quelle</span>
<span class="c1">-- les rayons sont lancé, la distance à la quel se trouve</span>
<span class="c1">-- le plan, et la taille de celui ci.</span>
<span class="kr">type</span> <span class="kt">Position</span> <span class="o">=</span> <span class="p">(</span><span class="kt">Double</span><span class="p">,</span> <span class="kt">Double</span><span class="p">,</span> <span class="kt">Double</span><span class="p">)</span>
<span class="kr">type</span> <span class="kt">Direction</span> <span class="o">=</span> <span class="p">(</span><span class="kt">Double</span><span class="p">,</span> <span class="kt">Double</span><span class="p">,</span> <span class="kt">Double</span><span class="p">)</span>
<span class="kr">type</span> <span class="kt">Distance</span> <span class="o">=</span> <span class="kt">Double</span>
<span class="kr">type</span> <span class="kt">Coordonnee</span> <span class="o">=</span> <span class="kt">Int</span>
<span class="kr">type</span> <span class="kt">Largeur</span> <span class="o">=</span> <span class="kt">Coordonnee</span>
<span class="kr">type</span> <span class="kt">Hauteur</span> <span class="o">=</span> <span class="kt">Coordonnee</span>
<span class="kr">type</span> <span class="kt">Plan</span> <span class="o">=</span> <span class="p">(</span><span class="kt">Largeur</span><span class="p">,</span> <span class="kt">Hauteur</span><span class="p">)</span>
<span class="kr">data</span> <span class="kt">Camera</span> <span class="o">=</span> <span class="kt">Camera</span> <span class="kt">Position</span> <span class="kt">Distance</span> <span class="kt">Plan</span>

<span class="n">getRay</span> <span class="o">::</span> <span class="kt">Cooronnee</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="kt">Camera</span> <span class="o">-&gt;</span> <span class="kt">Direction</span><span class="p">)</span>
<span class="n">getRay</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="n">cam</span> <span class="o">=</span> <span class="kr">let</span> <span class="p">(</span><span class="kt">Camera</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kr">_</span><span class="p">)</span> <span class="o">=</span> <span class="n">cam</span> <span class="kr">in</span> <span class="n">normalize</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">x</span><span class="p">,</span> <span class="n">j</span> <span class="o">-</span> <span class="n">y</span><span class="p">,</span> <span class="o">-</span><span class="n">z</span><span class="p">)</span>
  <span class="kr">where</span>
    <span class="n">normalize</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span> <span class="o">=</span> <span class="kr">let</span> <span class="n">norme</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="n">z</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span> <span class="kr">in</span> <span class="p">(</span><span class="n">x</span> <span class="o">/</span> <span class="n">norm</span><span class="p">,</span> <span class="n">y</span> <span class="o">/</span> <span class="n">norm</span><span class="p">,</span> <span class="n">z</span> <span class="o">/</span> <span class="n">norm</span><span class="p">)</span>

<span class="n">rayTraceScene</span> <span class="o">::</span> <span class="kt">Scene</span> <span class="o">-&gt;</span> <span class="kt">Direction</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="kt">Camera</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="kt">Object</span><span class="p">,</span> <span class="kt">Distance</span><span class="p">))</span>
<span class="n">rayTraceScene</span> <span class="o">=</span> <span class="c1">-- Imaginons que l'on fait le nécessaire pour raytracer une scène.</span>

<span class="n">computeColor</span> <span class="o">::</span> <span class="p">(</span><span class="kt">Object</span><span class="p">,</span> <span class="kt">Distance</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Camera</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="kt">Word8</span><span class="p">]</span>
<span class="n">computeColor</span> <span class="o">=</span> <span class="c1">-- Calcule la couleur en tenant compte de l'angle de la caméra, etc.</span>

<span class="c1">--Pour getPixel, on préférera souvent spécialiser d'abord la Caméra,</span>
<span class="c1">-- puis appeler cette spécialisation sur toute les coordonnées de l'image.</span>
<span class="c1">-- C'est pourquoi le type est "Camera -&gt; Coordonnee -&gt; [Word8]" plutôt</span>
<span class="c1">-- que "Coordonnee -&gt; Camera -&gt; [Word8]". On perd donc la possibilité</span>
<span class="c1">-- d'utiliser getPixel avec la monade "(-&gt;) Camera".</span>
<span class="n">getPixel</span> <span class="o">::</span> <span class="kt">Camera</span> <span class="o">-&gt;</span> <span class="kt">Coordonee</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="kt">Word8</span><span class="p">])</span>
<span class="n">getPixel</span> <span class="n">cam</span> <span class="n">coords</span> <span class="o">=</span> <span class="p">(</span><span class="n">return</span> <span class="n">coords</span> <span class="o">&gt;&gt;=</span> <span class="n">getRay</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="n">rayTraceScene</span> <span class="n">uneScene</span><span class="p">)</span> <span class="o">&gt;&gt;=</span> <span class="n">computeColor</span><span class="p">)</span> <span class="n">cam</span>
</code></pre></div></div>

<h3 id="point-culture">Point culture</h3>

<p>Comprenez bien que les monades ne sont pas indispensable, et que l’on faisait des monade avant la première apparition de la classe Monade. C’est simplement de nouveaux outils à votre disposition pour résoudre des problèmes, et ils permettent parfois de vieux problèmes de façon très élégante et concise (ce qui est un excellent pour l’évolutivité d’un code).</p>

<p>Sachez que les monades aussi doivent respecter certaines règles, tous comme les foncteurs et les foncteurs applicatifs. Cela assure qu’une monade seras bien un foncteur (applicatif), de la façon décrite plus haut. Les voici :</p>
<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- Neutre à gauche</span>
<span class="n">return</span> <span class="n">a</span> <span class="o">&gt;&gt;=</span> <span class="n">f</span> <span class="o">=</span> <span class="n">f</span> <span class="n">a</span>
<span class="c1">-- Neutre à droite</span>
<span class="n">m</span> <span class="o">&gt;&gt;=</span> <span class="n">return</span> <span class="o">=</span> <span class="n">m</span>
<span class="c1">-- Associativité</span>
<span class="p">(</span><span class="n">m</span> <span class="o">&gt;&gt;=</span> <span class="n">f</span><span class="p">)</span> <span class="o">&gt;&gt;=</span> <span class="n">g</span> <span class="o">=</span> <span class="n">m</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">x</span> <span class="o">&gt;&gt;=</span> <span class="n">g</span><span class="p">)</span>
</code></pre></div></div>

<p>Vous trouverez des liens dans les références pour plus de détails.</p>

<p>On n’a pas aborder la monade IO. Cette monade permet de ramener les actions propre a l’impératif, les “effets de bord”, dans le langage haskell. L’astuce diabolique est la suivante : Puisque qu’un programme haskell ne peut produire d’effet de bord, un programme haskell décriras comment composer, jusxtaposer, et transformer les résultats produits par des programmes impératif. Utiliser la monade IO, c’est jouer avec la composition et la juxtaposition de programmes. C’est alors que l’opérateur <code class="highlighter-rouge">&gt;&gt;</code> prend tout son sens! Il permet de juxtaposer deux programmes impératifs et ne retenir le résultat que du second, par exemple :</p>
<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">afficherMessage</span> <span class="o">=</span> <span class="n">putStrLn</span> <span class="s">"Bonjour,"</span> <span class="o">&gt;&gt;</span> <span class="n">putStrLn</span> <span class="s">"monde!"</span>
</code></pre></div></div>

<p>En dire plus sur cette monade n’a d’intérêts que pour les personne voulant écrire des programmes en haskell. Si c’est votre cas, je vous invite à lire, au choix, Learn You Haskell for Great Good ou (plus technique et plus … “professionnel”) Real World Haskell, chez O’Reilly.</p>

<h3 id="références-">Références :</h3>

<ul>
  <li><a href="http://www.haskell.org/haskellwiki/Monad_laws">Les lois respectés par les monades</a></li>
  <li>La monade <a href="http://hackage.haskell.org/packages/archive/category-extras/0.53.1/doc/html/Control-Monad-Either.html">Either</a></li>
  <li>Le moteur de recherche haskell <a href="http://www.haskell.org/hoogle/">Hoogle</a>. Permet de rechercher une fonction à partir de son type.</li>
</ul>


</div>

<div class="related">
  <h2>Related Posts</h2>
  <ul class="related-posts">
    
      <li>
        <h3>
          <a href="/what-is-wrong-with-the-object-paradigm/">
            What is wrong with the object paradigm ?
            <small>17 Feb 2017</small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/boost-property-tree/">
            How to use boost::property_tree to load and write JSON
            <small>21 Dec 2015</small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/an-alternative-error-handling-strategy-cpp/">
            An alternative error handling strategy for C++
            <small>27 Aug 2013</small>
          </a>
        </h3>
      </li>
    
  </ul>
</div>

    </div>

    
    <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-10762787-1', 'auto');
    ga('send', 'pageview');
</script>
    

    <footer class="footer">
  <hr/>
  <div class="container">
    <div class="row">
      <p class="text-muted col-sm-10 text-center">
            <span class="sidebar-nav-item small">Make a donation. 😇</span>
            <span class="sidebar-nav-item x-small">BTC: <a href="bitcoin:1JcME7DSCw8b83nEGFKUYTKE4LM8aX4dhJ">1JcME7DSCw8b83nEGFKUYTKE4LM8aX4dhJ</a></span>
            <span class="sidebar-nav-item x-small">ETH: <a href="ethereum:eA22ADf19f20D618D8EF66E4704C540A10708F1F">eA22ADf19f20D618D8EF66E4704C540A10708F1F</a></span>
      </p>
      <p class="col-sm-2">
        <a class="twitter-share-button col-sm"
           href="https://twitter.com/share"
           data-via="Zenol42">
          Tweet
        </a>
      </p>
    </div>
  </div>
</footer>

<!-- Bootstrap core JavaScript
================================================== -->
<!-- Placed at the end of the document so the pages load faster -->
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="/bootstrap/js/vendor/jquery.min.js"><\/script>')</script>
<script src="/public/bootstrap/js/bootstrap.min.js"></script>

<!-- Twitter sharing button loader -->
<script>
  window.twttr = (function(d, s, id) {
    var js, fjs = d.getElementsByTagName(s)[0],
      t = window.twttr || {};
    if (d.getElementById(id)) return t;
    js = d.createElement(s);
    js.id = id;
    js.src = "https://platform.twitter.com/widgets.js";
    fjs.parentNode.insertBefore(js, fjs);

    t._e = [];
    t.ready = function(f) {
      t._e.push(f);
    };

    return t;
  }(document, "script", "twitter-wjs"));
</script>

  </body>
</html>
