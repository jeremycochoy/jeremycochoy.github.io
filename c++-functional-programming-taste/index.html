<!DOCTYPE html>
<html lang="en-us">

  <head>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <meta name="description" content="Jeremy Cochoy's personal website.">
  <meta name="author" content="Jeremy Cochoy">

  <title>
    
      C++ - Un gout de programmation fonctionelle &middot; Jeremy Cochoy
    
  </title>

  <!-- CSS -->
  <link href="/public/bootstrap/css/bootstrap.min.css" rel="stylesheet">
  <link rel="stylesheet" href="/public/css/poole.css">
  <link rel="stylesheet" href="/public/css/syntax.css">
  <link rel="stylesheet" href="/public/css/hyde.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">
  <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
  <!--[if lt IE 9]>
  	<script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
  	<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
	<![endif]-->

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/apple-touch-icon-precomposed.png">
  <link rel="shortcut icon" href="/public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">

  <!-- Custom styles for this template -->
  <link href="/public/style.css" rel="stylesheet">

  <!-- Maths equations -->
  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$','$'], ['\\(','\\)']],
      processEscapes: true
    }
  });
  </script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
</head>


  <body>

    <!-- Fixed navbar -->
<nav class="navbar navbar-default navbar-fixed-top">
 <div class="container">
   <div class="navbar-header">
     <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
 <span class="sr-only">Toggle navigation</span>
 <span class="icon-bar"></span>
 <span class="icon-bar"></span>
 <span class="icon-bar"></span>
     </button>
     <a class="navbar-brand" href="/">Jeremy Cochoy</a>
   </div>
   <div id="navbar" class="collapse navbar-collapse">
     <ul class="nav navbar-nav">
     <li><a href="/resume/">Resume</a></li>
 <li><a href="/blog/">Blog</a></li>
 <li role="separator" class="divider"></li>
 <li><a href="/talks/">Talks</a></li>
 <li><a href="/research/">Research</a></li>
 <li><a href="/teaching/">Teaching</a></li>
 <li><a href="/music/">Music</a></li>
 <li class="dropdown">
   <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">More <span class="caret"></span></a>
   <ul class="dropdown-menu">
     <li><a href="/hyper-flop/">Hyper-Flop</a></li>
     <li role="separator" class="divider"></li>
     <li><a href="/pdfs/">PDFs & Talks</a></li>
     <li><a href="/agreg-dev/">Agregation de mathématique</a></li>
     <li role="separator" class="divider"></li>
     <li><a href="https://github.com/jeremycochoy/sednl" alt="SEDNL Github">SEDNL (Github)</a></li>
     <li><a href="http://sednl.zenol.fr" alt="Simple Event Driven Network Library">SEDNL</a></li>
           <li role="separator" class="divider"></li>
           <li><a href="/gb-doc">GameBoy Emulator Documentation</a></li>
   </ul>
 </li>
     </ul>
   </div><!--/.nav-collapse -->
 </div>
</nav>


    <div class="container">
      <div class="post">
  <h1 class="post-title">C++ - Un gout de programmation fonctionelle</h1>
  <span class="post-date">12 Jul 2013</span>
  <p>Dans ce billet, nous allons aborder quelques unes des nouvelles fonctionnalités offerte par le C++11. Elles sont clairement inspiré de la vie dans le monde fonctionnel.</p>

<h2 id="alpha-beta--kappa-lambda">Alpha, Beta, … Kappa, Lambda!</h2>

<p>Bien que portant le même nom, les <em>lambda</em>(C++ 11 powered) sont très différentes de leur homologues fonctionnelles, les <em>lambda fonctions</em>. Une lambda en C++11, c’est plutôt une intégration au langage des foncteurs.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">AFunctor</span>
<span class="p">{</span>
<span class="nl">public:</span>
  <span class="kt">int</span> <span class="k">operator</span> <span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span><span class="p">;</span> <span class="p">}</span>
  <span class="kt">int</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// ...</span>
<span class="n">AFunctor</span> <span class="n">f</span><span class="p">;</span>
<span class="n">f</span><span class="p">.</span><span class="n">b</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">f</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">//Display 84</span>
</code></pre></div></div>

<p>Ré-écrivons la même chose avec la syntaxe d’une lambda, que l’on détaillera un peu plus loin (auto permet de laisser le compilateur inférer(deviner) le type).</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">f</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="n">b</span><span class="p">](</span><span class="kt">int</span> <span class="n">a</span><span class="p">){</span><span class="k">return</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span><span class="p">};</span>
</code></pre></div></div>

<p>Les lambda permette de faire la même chose de façon plus légère, et ajoute la sémantique de fonction (i.e. on ne peux pas confondre une lambda et un objet en lisant du code, alors qu’on ‘'’pourrait’’’ avec un foncteur et un objet). Les lambda sont aussi plus proche de d’une fonction anonyme, puisque certaines fonctions (constructeur, opérateur =), implicitement déclaré dans l’exemple ci dessus (on peux faire f = g avec f et g deux AFunctor) n’existent pas (sont explicitement supprimé) pour les lambda.</p>

<p>Par exemple, le constructeur du type d’une lambda (on rappelle qu’en c++11, on peux obtenir le type de <code class="language-plaintext highlighter-rouge">f</code> avec <code class="language-plaintext highlighter-rouge">decltype(f)</code>. Par exemple <code class="language-plaintext highlighter-rouge">decltype(3.5f)</code> ou <code class="language-plaintext highlighter-rouge">std::vector v; decltype(v)</code>) n’existe pas.</p>

<p>Si f est une lambda, le code <code class="language-plaintext highlighter-rouge">decltype(f) g;</code> ne compilera pas. Pourtant, si <code class="language-plaintext highlighter-rouge">f</code> est un <code class="language-plaintext highlighter-rouge">AFunctor</code>, le code <code class="language-plaintext highlighter-rouge">decltype(f) g;</code> compilera et correspond à <code class="language-plaintext highlighter-rouge">AFunctor g;</code>.</p>

<p>Bon, qu’on se rassure, on peux quand même faire une copie d’une lambda :</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">auto</span> <span class="n">f</span> <span class="o">=</span> <span class="p">[](){</span><span class="k">return</span> <span class="mi">42</span><span class="p">};</span>

<span class="k">auto</span>        <span class="n">g1</span> <span class="o">=</span> <span class="n">f</span><span class="p">;</span>
<span class="c1">//Or</span>
<span class="k">auto</span>        <span class="nf">g2</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
<span class="c1">//Or</span>
<span class="k">decltype</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="n">g3</span> <span class="o">=</span> <span class="n">f</span><span class="p">;</span>
<span class="c1">//Or</span>
<span class="k">decltype</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="n">g4</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
</code></pre></div></div>

<h2 id="comment-fonctionne-une-lambda">Comment fonctionne une lambda?</h2>

<p>En fait, c’est très simple, est tout est décrit sur la page “Lambda” du site “CPPReference”.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span> <span class="n">capture</span> <span class="p">]</span> <span class="p">(</span> <span class="n">params</span> <span class="p">)</span> <span class="k">mutable</span> <span class="n">exception</span> <span class="n">attribute</span> <span class="o">-&gt;</span> <span class="n">ret</span> <span class="p">{</span> <span class="n">body</span> <span class="p">}</span>
</code></pre></div></div>

<p>Dans capture on trouve la façon dont les variables extérieurs à la lambda sont capturé. Il y a deux mode de capture : par valeur, et par référence. Par défaut, [] signifie [=] qui veux dire “tout est récupérer par valeur”, et le comportement est identique à une copie des variable(pour les objets comme <code class="language-plaintext highlighter-rouge">std::string</code>, c’est plutôt un <code class="language-plaintext highlighter-rouge">const std::string&amp;</code> que vous recevez). On peux aussi spécifier [&amp;] et toute les variables sont récupérées par référence (et peuvent donc être modifiées depuis la lambda). Enfin, pour ceux qui apprécient la finesse, on peux expliciter le comportement pour chacune des variables, par exemple :</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">msg</span> <span class="o">=</span> <span class="s">"Hello"</span><span class="p">;</span>
<span class="c1">//Take a by value</span>
<span class="k">auto</span> <span class="n">f1</span> <span class="o">=</span> <span class="p">[](){</span><span class="k">return</span> <span class="n">a</span><span class="p">;}</span>
<span class="c1">//Same, but tell explicitely the return type</span>
<span class="k">auto</span> <span class="n">f2</span> <span class="o">=</span> <span class="p">[]()</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="p">{</span><span class="k">return</span> <span class="n">a</span><span class="p">;}</span>
<span class="c1">//Always the same</span>
<span class="k">auto</span> <span class="n">f3</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="p">](){</span><span class="k">return</span> <span class="n">a</span><span class="p">;}</span>

<span class="c1">//Take v by ref and a by value (return type is void)</span>
<span class="k">auto</span> <span class="n">f4</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">]()</span> <span class="p">{</span><span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">a</span><span class="p">);}</span>

<span class="c1">//Take everybody by ref</span>
<span class="k">auto</span> <span class="n">f5</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">]()</span> <span class="p">{</span><span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">a</span><span class="p">);</span> <span class="n">a</span><span class="o">++</span><span class="p">;</span> <span class="n">msg</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="sc">'!'</span><span class="p">);</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">msg</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;}</span>
</code></pre></div></div>

<p>La partie “exception” correspond aux spécifications du genre <code class="language-plaintext highlighter-rouge">throw (std::bad_alloc, MyExceptionType)</code> ou encore <code class="language-plaintext highlighter-rouge">noexcept</code> (no throw exception safety).</p>

<p>Si vous voulez modifier un objet obtenu par valeur, il vous faudra rajouter “mutable”. Cela peux être très utile, si vous voulez appeler des méthodes non const sur une copie d’un objet dans le scope.</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">f</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span><span class="p">]()</span> <span class="k">mutable</span> <span class="p">{</span><span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;}</span>
</code></pre></div></div>

<p>Petite astuce parfois utile : Si une lambda ne capture aucune variable, alors elle peux être convertie en pointeur de fonction.</p>

<h2 id="stdfunction-">std::function :</h2>

<p>Les std::function représente des fonctions. Ils sont basé sur les templates variadique (l’un des ajout les plus puissant au langage), que l’on peux espérer disponible sous VisualStudio d’ici 2039 (si l’équipe de microsoft ne prend pas de retard). Le constructeur des std::function autorise de les construire avec plus ou moins n’importe quoi (pointeur de fonction, pointeur de fonction membre, lambda, foncteur, …).</p>

<p>En code :</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//Lambda</span>
<span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">f</span> <span class="o">=</span> <span class="p">[](</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="o">=</span> <span class="p">{</span><span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;}</span>

<span class="c1">//Function</span>
<span class="kt">void</span> <span class="nf">print</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">f</span> <span class="o">=</span> <span class="n">print</span><span class="p">;</span>

<span class="c1">//Functor</span>
<span class="k">struct</span> <span class="nc">Functor</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">b</span><span class="p">;</span>
    <span class="kt">int</span> <span class="k">operator</span> <span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;};</span>
<span class="p">};</span>

<span class="n">Functor</span> <span class="n">func</span><span class="p">;</span>
<span class="n">func</span><span class="p">.</span><span class="n">b</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>    
<span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">f</span> <span class="o">=</span> <span class="n">func</span><span class="p">;</span>

<span class="c1">//Member function</span>
<span class="k">struct</span> <span class="nc">St</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">b</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">sum</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span> <span class="p">};</span>
<span class="p">}</span>
<span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="k">const</span> <span class="n">St</span><span class="o">&amp;</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">f</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">St</span><span class="o">::</span><span class="n">sum</span><span class="p">;</span>

</code></pre></div></div>

<h2 id="application-partielle">Application partielle.</h2>

<p>Tout ça, pour en venir à vous parler de <code class="language-plaintext highlighter-rouge">std::bind</code>. Quand on travail avec des langages fonctionnels, on peux appeler une fonction avec seulement une partie de ses arguments. On parle d’<em>application partielle</em>. <code class="language-plaintext highlighter-rouge">std::bind</code> permet de reproduire ce comportement. Prenons une innocente fonction :</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">display</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"a : "</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="s">" - b :"</span> <span class="o">&lt;&lt;</span> <span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="s">" - c : "</span> <span class="o">&lt;&lt;</span> <span class="n">c</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>On peux alors construire, grâce à std::bind, différentes spécialisation de cette fonction :</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//On fixe les trois arguments</span>
<span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">()</span><span class="o">&gt;</span> <span class="n">f</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">display</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">);</span>
<span class="n">f</span><span class="p">();</span> <span class="c1">// Affiche a : 5 - b : 6 - c : 7</span>
<span class="c1">//On fixe les trois, et on en rajoute un qui sera ignoré</span>
<span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">f</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">display</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">);</span>
<span class="n">f</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span> <span class="c1">// Affiche a : 5 - b : 6 - c : 7</span>

<span class="c1">//Placeholders::_i désigne le i-ième argument lors de l’appelle de f</span>
<span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">f</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">display</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">placeholders</span><span class="o">::</span><span class="n">_1</span><span class="p">);</span>
<span class="n">f</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span> <span class="c1">//  Affiche a : 5 - b : 6 - c : 42</span>

<span class="c1">//Ne fixe que le premier argument</span>
<span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">f</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">display</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">placeholders</span><span class="o">::</span><span class="n">_1</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">placeholders</span><span class="o">::</span><span class="n">_2</span><span class="p">);</span>
<span class="n">f</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span> <span class="c1">//  Affiche a : 5 - b : 10 - c : 20</span>

<span class="c1">//On peux changer l'ordre :</span>
<span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">f</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">display</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">placeholders</span><span class="o">::</span><span class="n">_2</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">placeholders</span><span class="o">::</span><span class="n">_1</span><span class="p">);</span>
<span class="n">f</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span> <span class="c1">//  Affiche a : 5 - b : 20 - c : 10</span>

</code></pre></div></div>

<p>Bien entendu, on peux aussi faire des choses plus complexe (passage des arguments par référence avec <code class="language-plaintext highlighter-rouge">std::ref</code> et <code class="language-plaintext highlighter-rouge">std::cref</code> dans les arguments de bind, pointeurs de fonction membre, pointeur vers membres, etc.).</p>

<p>Si vous vous demandez à quoi ça peux bien servir, et bien dite vous que là où on attend une callback avec une certaine signature (c’est le cas avec beaucoup d’outil de <code class="language-plaintext highlighter-rouge">&lt;algorithm&gt;</code>) vous avez maintenant la possibilité de spécialiser vos fonctions.</p>

<p>Pour ce qui est du coût, il est faible (celons les cas beaucoup de choses peuvent être optimisé lors de la compilation), et n’est un argument recevable que dans certains cas particulier. Donc, à moins de faire du temps réel et de faire ce genre de manipulation dans les parties critique, vous pouvez vous lâcher.</p>

<p>Voilà, j’espère vous avoir donné un petit aperçu de l’apport du c++11 en matière de manipulation des fonctions.</p>

<h2 id="références-">Références :</h2>

<ul>
  <li><a href="http://en.cppreference.com/w/cpp/language/lambda">http://en.cppreference.com/w/cpp/language/lambda</a></li>
  <li><a href="http://en.cppreference.com/w/cpp/utility/functional/function">http://en.cppreference.com/w/cpp/utility/functional/function</a></li>
</ul>

</div>

<div class="related">
  <h2>Related Posts</h2>
  <ul class="related-posts">
    
      <li>
        <h3>
          <a href="/list-zipper-swift/">
            List Zipper applied to iOS swift
            <small>24 May 2019</small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/what-is-wrong-with-the-object-paradigm/">
            What is wrong with the object paradigm ?
            <small>17 Feb 2017</small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/boost-property-tree/">
            How to use boost::property_tree to load and write JSON
            <small>21 Dec 2015</small>
          </a>
        </h3>
      </li>
    
  </ul>
</div>

    </div>

    
    <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-10762787-1', 'auto');
    ga('send', 'pageview');
</script>
    

    <footer class="footer">
  <hr/>
  <div class="container">
    <div class="row">
      <p class="text-muted col-sm-10 text-center">
            <span class="sidebar-nav-item small">Make a donation. 😇</span>
            <span class="sidebar-nav-item x-small">BTC: <a href="bitcoin:1JcME7DSCw8b83nEGFKUYTKE4LM8aX4dhJ">1JcME7DSCw8b83nEGFKUYTKE4LM8aX4dhJ</a></span>
            <span class="sidebar-nav-item x-small">ETH: <a href="ethereum:eA22ADf19f20D618D8EF66E4704C540A10708F1F">eA22ADf19f20D618D8EF66E4704C540A10708F1F</a></span>
      </p>
      <p class="col-sm-2">
        <a class="twitter-share-button col-sm"
           href="https://twitter.com/share"
           data-via="Zenol42">
          Tweet
        </a>
      </p>
    </div>
  </div>
</footer>

<!-- Bootstrap core JavaScript
================================================== -->
<!-- Placed at the end of the document so the pages load faster -->
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="/bootstrap/js/vendor/jquery.min.js"><\/script>')</script>
<script src="/public/bootstrap/js/bootstrap.min.js"></script>

<!-- Twitter sharing button loader -->
<script>
  window.twttr = (function(d, s, id) {
    var js, fjs = d.getElementsByTagName(s)[0],
      t = window.twttr || {};
    if (d.getElementById(id)) return t;
    js = d.createElement(s);
    js.id = id;
    js.src = "https://platform.twitter.com/widgets.js";
    fjs.parentNode.insertBefore(js, fjs);

    t._e = [];
    t.ready = function(f) {
      t._e.push(f);
    };

    return t;
  }(document, "script", "twitter-wjs"));
</script>

  </body>
</html>
