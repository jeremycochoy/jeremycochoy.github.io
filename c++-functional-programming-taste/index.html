<!DOCTYPE html>
<html lang="en-us">

  <head>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <meta name="description" content="Jeremy Cochoy's personal website.">
  <meta name="author" content="Jeremy Cochoy">

  <title>
    
      C++ - Un gout de programmation fonctionelle &middot; Jeremy Cochoy
    
  </title>

  <!-- CSS -->
  <link href="/public/bootstrap/css/bootstrap.min.css" rel="stylesheet">
  <link rel="stylesheet" href="/public/css/poole.css">
  <link rel="stylesheet" href="/public/css/syntax.css">
  <link rel="stylesheet" href="/public/css/hyde.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">
  <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
  <!--[if lt IE 9]>
  	<script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
  	<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
	<![endif]-->

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/apple-touch-icon-precomposed.png">
  <link rel="shortcut icon" href="/public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">

  <!-- Custom styles for this template -->
  <link href="/public/style.css" rel="stylesheet">

  <!-- Maths equations -->
  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$','$'], ['\\(','\\)']],
      processEscapes: true
    }
  });
  </script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
</head>


  <body>

    <!-- Fixed navbar -->
<nav class="navbar navbar-default navbar-fixed-top">
 <div class="container">
   <div class="navbar-header">
     <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
 <span class="sr-only">Toggle navigation</span>
 <span class="icon-bar"></span>
 <span class="icon-bar"></span>
 <span class="icon-bar"></span>
     </button>
     <a class="navbar-brand" href="/">Jeremy Cochoy</a>
   </div>
   <div id="navbar" class="collapse navbar-collapse">
     <ul class="nav navbar-nav">
     <li><a href="/resume/">Resume</a></li>
 <li><a href="/blog/">Blog</a></li>
 <li role="separator" class="divider"></li>
 <li><a href="/talks/">Talks</a></li>
 <li><a href="/research/">Research</a></li>
 <li><a href="/teaching/">Teaching</a></li>
 <li><a href="/music/">Music</a></li>
 <li class="dropdown">
   <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">More <span class="caret"></span></a>
   <ul class="dropdown-menu">
     <li><a href="/hyper-flop/">Hyper-Flop</a></li>
     <li role="separator" class="divider"></li>
     <li><a href="/pdfs/">PDFs & Talks</a></li>
     <li><a href="/agreg-dev/">Agregation de math√©matique</a></li>
     <li role="separator" class="divider"></li>
     <li><a href="https://github.com/jeremycochoy/sednl" alt="SEDNL Github">SEDNL (Github)</a></li>
     <li><a href="http://sednl.zenol.fr" alt="Simple Event Driven Network Library">SEDNL</a></li>
           <li role="separator" class="divider"></li>
           <li><a href="/gb-doc">GameBoy Emulator Documentation</a></li>
   </ul>
 </li>
     </ul>
   </div><!--/.nav-collapse -->
 </div>
</nav>


    <div class="container">
      <div class="post">
  <h1 class="post-title">C++ - Un gout de programmation fonctionelle</h1>
  <span class="post-date">12 Jul 2013</span>
  <p>Dans ce billet, nous allons aborder quelques unes des nouvelles fonctionnalit√©s offerte par le C++11. Elles sont clairement inspir√© de la vie dans le monde fonctionnel.</p>

<h2 id="alpha-beta--kappa-lambda">Alpha, Beta, ‚Ä¶ Kappa, Lambda!</h2>

<p>Bien que portant le m√™me nom, les <em>lambda</em>(C++ 11 powered) sont tr√®s diff√©rentes de leur homologues fonctionnelles, les <em>lambda fonctions</em>. Une lambda en C++11, c‚Äôest plut√¥t une int√©gration au langage des foncteurs.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">AFunctor</span>
<span class="p">{</span>
<span class="nl">public:</span>
  <span class="kt">int</span> <span class="k">operator</span> <span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span><span class="p">;</span> <span class="p">}</span>
  <span class="kt">int</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// ...</span>
<span class="n">AFunctor</span> <span class="n">f</span><span class="p">;</span>
<span class="n">f</span><span class="p">.</span><span class="n">b</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">f</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">//Display 84</span>
</code></pre></div></div>

<p>R√©-√©crivons la m√™me chose avec la syntaxe d‚Äôune lambda, que l‚Äôon d√©taillera un peu plus loin (auto permet de laisser le compilateur inf√©rer(deviner) le type).</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">f</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="n">b</span><span class="p">](</span><span class="kt">int</span> <span class="n">a</span><span class="p">){</span><span class="k">return</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span><span class="p">};</span>
</code></pre></div></div>

<p>Les lambda permette de faire la m√™me chose de fa√ßon plus l√©g√®re, et ajoute la s√©mantique de fonction (i.e. on ne peux pas confondre une lambda et un objet en lisant du code, alors qu‚Äôon ‚Äò'‚Äôpourrait‚Äô‚Äô‚Äô avec un foncteur et un objet). Les lambda sont aussi plus proche de d‚Äôune fonction anonyme, puisque certaines fonctions (constructeur, op√©rateur =), implicitement d√©clar√© dans l‚Äôexemple ci dessus (on peux faire f = g avec f et g deux AFunctor) n‚Äôexistent pas (sont explicitement supprim√©) pour les lambda.</p>

<p>Par exemple, le constructeur du type d‚Äôune lambda (on rappelle qu‚Äôen c++11, on peux obtenir le type de <code class="language-plaintext highlighter-rouge">f</code> avec <code class="language-plaintext highlighter-rouge">decltype(f)</code>. Par exemple <code class="language-plaintext highlighter-rouge">decltype(3.5f)</code> ou <code class="language-plaintext highlighter-rouge">std::vector v; decltype(v)</code>) n‚Äôexiste pas.</p>

<p>Si f est une lambda, le code <code class="language-plaintext highlighter-rouge">decltype(f) g;</code> ne compilera pas. Pourtant, si <code class="language-plaintext highlighter-rouge">f</code> est un <code class="language-plaintext highlighter-rouge">AFunctor</code>, le code <code class="language-plaintext highlighter-rouge">decltype(f) g;</code> compilera et correspond √† <code class="language-plaintext highlighter-rouge">AFunctor g;</code>.</p>

<p>Bon, qu‚Äôon se rassure, on peux quand m√™me faire une copie d‚Äôune lambda :</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">auto</span> <span class="n">f</span> <span class="o">=</span> <span class="p">[](){</span><span class="k">return</span> <span class="mi">42</span><span class="p">};</span>

<span class="k">auto</span>        <span class="n">g1</span> <span class="o">=</span> <span class="n">f</span><span class="p">;</span>
<span class="c1">//Or</span>
<span class="k">auto</span>        <span class="nf">g2</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
<span class="c1">//Or</span>
<span class="k">decltype</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="n">g3</span> <span class="o">=</span> <span class="n">f</span><span class="p">;</span>
<span class="c1">//Or</span>
<span class="k">decltype</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="n">g4</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
</code></pre></div></div>

<h2 id="comment-fonctionne-une-lambda">Comment fonctionne une lambda?</h2>

<p>En fait, c‚Äôest tr√®s simple, est tout est d√©crit sur la page ‚ÄúLambda‚Äù du site ‚ÄúCPPReference‚Äù.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span> <span class="n">capture</span> <span class="p">]</span> <span class="p">(</span> <span class="n">params</span> <span class="p">)</span> <span class="k">mutable</span> <span class="n">exception</span> <span class="n">attribute</span> <span class="o">-&gt;</span> <span class="n">ret</span> <span class="p">{</span> <span class="n">body</span> <span class="p">}</span>
</code></pre></div></div>

<p>Dans capture on trouve la fa√ßon dont les variables ext√©rieurs √† la lambda sont captur√©. Il y a deux mode de capture : par valeur, et par r√©f√©rence. Par d√©faut, [] signifie [=] qui veux dire ‚Äútout est r√©cup√©rer par valeur‚Äù, et le comportement est identique √† une copie des variable(pour les objets comme <code class="language-plaintext highlighter-rouge">std::string</code>, c‚Äôest plut√¥t un <code class="language-plaintext highlighter-rouge">const std::string&amp;</code> que vous recevez). On peux aussi sp√©cifier [&amp;] et toute les variables sont r√©cup√©r√©es par r√©f√©rence (et peuvent donc √™tre modifi√©es depuis la lambda). Enfin, pour ceux qui appr√©cient la finesse, on peux expliciter le comportement pour chacune des variables, par exemple :</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">msg</span> <span class="o">=</span> <span class="s">"Hello"</span><span class="p">;</span>
<span class="c1">//Take a by value</span>
<span class="k">auto</span> <span class="n">f1</span> <span class="o">=</span> <span class="p">[](){</span><span class="k">return</span> <span class="n">a</span><span class="p">;}</span>
<span class="c1">//Same, but tell explicitely the return type</span>
<span class="k">auto</span> <span class="n">f2</span> <span class="o">=</span> <span class="p">[]()</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="p">{</span><span class="k">return</span> <span class="n">a</span><span class="p">;}</span>
<span class="c1">//Always the same</span>
<span class="k">auto</span> <span class="n">f3</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="p">](){</span><span class="k">return</span> <span class="n">a</span><span class="p">;}</span>

<span class="c1">//Take v by ref and a by value (return type is void)</span>
<span class="k">auto</span> <span class="n">f4</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">]()</span> <span class="p">{</span><span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">a</span><span class="p">);}</span>

<span class="c1">//Take everybody by ref</span>
<span class="k">auto</span> <span class="n">f5</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">]()</span> <span class="p">{</span><span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">a</span><span class="p">);</span> <span class="n">a</span><span class="o">++</span><span class="p">;</span> <span class="n">msg</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="sc">'!'</span><span class="p">);</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">msg</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;}</span>
</code></pre></div></div>

<p>La partie ‚Äúexception‚Äù correspond aux sp√©cifications du genre <code class="language-plaintext highlighter-rouge">throw (std::bad_alloc, MyExceptionType)</code> ou encore <code class="language-plaintext highlighter-rouge">noexcept</code> (no throw exception safety).</p>

<p>Si vous voulez modifier un objet obtenu par valeur, il vous faudra rajouter ‚Äúmutable‚Äù. Cela peux √™tre tr√®s utile, si vous voulez appeler des m√©thodes non const sur une copie d‚Äôun objet dans le scope.</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">f</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span><span class="p">]()</span> <span class="k">mutable</span> <span class="p">{</span><span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;}</span>
</code></pre></div></div>

<p>Petite astuce parfois utile : Si une lambda ne capture aucune variable, alors elle peux √™tre convertie en pointeur de fonction.</p>

<h2 id="stdfunction-">std::function :</h2>

<p>Les std::function repr√©sente des fonctions. Ils sont bas√© sur les templates variadique (l‚Äôun des ajout les plus puissant au langage), que l‚Äôon peux esp√©rer disponible sous VisualStudio d‚Äôici 2039 (si l‚Äô√©quipe de microsoft ne prend pas de retard). Le constructeur des std::function autorise de les construire avec plus ou moins n‚Äôimporte quoi (pointeur de fonction, pointeur de fonction membre, lambda, foncteur, ‚Ä¶).</p>

<p>En code :</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//Lambda</span>
<span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">f</span> <span class="o">=</span> <span class="p">[](</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="o">=</span> <span class="p">{</span><span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;}</span>

<span class="c1">//Function</span>
<span class="kt">void</span> <span class="nf">print</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">f</span> <span class="o">=</span> <span class="n">print</span><span class="p">;</span>

<span class="c1">//Functor</span>
<span class="k">struct</span> <span class="nc">Functor</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">b</span><span class="p">;</span>
    <span class="kt">int</span> <span class="k">operator</span> <span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;};</span>
<span class="p">};</span>

<span class="n">Functor</span> <span class="n">func</span><span class="p">;</span>
<span class="n">func</span><span class="p">.</span><span class="n">b</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>    
<span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">f</span> <span class="o">=</span> <span class="n">func</span><span class="p">;</span>

<span class="c1">//Member function</span>
<span class="k">struct</span> <span class="nc">St</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">b</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">sum</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span> <span class="p">};</span>
<span class="p">}</span>
<span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="k">const</span> <span class="n">St</span><span class="o">&amp;</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">f</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">St</span><span class="o">::</span><span class="n">sum</span><span class="p">;</span>

</code></pre></div></div>

<h2 id="application-partielle">Application partielle.</h2>

<p>Tout √ßa, pour en venir √† vous parler de <code class="language-plaintext highlighter-rouge">std::bind</code>. Quand on travail avec des langages fonctionnels, on peux appeler une fonction avec seulement une partie de ses arguments. On parle d‚Äô<em>application partielle</em>. <code class="language-plaintext highlighter-rouge">std::bind</code> permet de reproduire ce comportement. Prenons une innocente fonction :</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">display</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"a : "</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="s">" - b :"</span> <span class="o">&lt;&lt;</span> <span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="s">" - c : "</span> <span class="o">&lt;&lt;</span> <span class="n">c</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>On peux alors construire, gr√¢ce √† std::bind, diff√©rentes sp√©cialisation de cette fonction :</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//On fixe les trois arguments</span>
<span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">()</span><span class="o">&gt;</span> <span class="n">f</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">display</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">);</span>
<span class="n">f</span><span class="p">();</span> <span class="c1">// Affiche a : 5 - b : 6 - c : 7</span>
<span class="c1">//On fixe les trois, et on en rajoute un qui sera ignor√©</span>
<span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">f</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">display</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">);</span>
<span class="n">f</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span> <span class="c1">// Affiche a : 5 - b : 6 - c : 7</span>

<span class="c1">//Placeholders::_i d√©signe le i-i√®me argument lors de l‚Äôappelle de f</span>
<span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">f</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">display</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">placeholders</span><span class="o">::</span><span class="n">_1</span><span class="p">);</span>
<span class="n">f</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span> <span class="c1">//  Affiche a : 5 - b : 6 - c : 42</span>

<span class="c1">//Ne fixe que le premier argument</span>
<span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">f</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">display</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">placeholders</span><span class="o">::</span><span class="n">_1</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">placeholders</span><span class="o">::</span><span class="n">_2</span><span class="p">);</span>
<span class="n">f</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span> <span class="c1">//  Affiche a : 5 - b : 10 - c : 20</span>

<span class="c1">//On peux changer l'ordre :</span>
<span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">f</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">display</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">placeholders</span><span class="o">::</span><span class="n">_2</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">placeholders</span><span class="o">::</span><span class="n">_1</span><span class="p">);</span>
<span class="n">f</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span> <span class="c1">//  Affiche a : 5 - b : 20 - c : 10</span>

</code></pre></div></div>

<p>Bien entendu, on peux aussi faire des choses plus complexe (passage des arguments par r√©f√©rence avec <code class="language-plaintext highlighter-rouge">std::ref</code> et <code class="language-plaintext highlighter-rouge">std::cref</code> dans les arguments de bind, pointeurs de fonction membre, pointeur vers membres, etc.).</p>

<p>Si vous vous demandez √† quoi √ßa peux bien servir, et bien dite vous que l√† o√π on attend une callback avec une certaine signature (c‚Äôest le cas avec beaucoup d‚Äôoutil de <code class="language-plaintext highlighter-rouge">&lt;algorithm&gt;</code>) vous avez maintenant la possibilit√© de sp√©cialiser vos fonctions.</p>

<p>Pour ce qui est du co√ªt, il est faible (celons les cas beaucoup de choses peuvent √™tre optimis√© lors de la compilation), et n‚Äôest un argument recevable que dans certains cas particulier. Donc, √† moins de faire du temps r√©el et de faire ce genre de manipulation dans les parties critique, vous pouvez vous l√¢cher.</p>

<p>Voil√†, j‚Äôesp√®re vous avoir donn√© un petit aper√ßu de l‚Äôapport du c++11 en mati√®re de manipulation des fonctions.</p>

<h2 id="r√©f√©rences-">R√©f√©rences :</h2>

<ul>
  <li><a href="http://en.cppreference.com/w/cpp/language/lambda">http://en.cppreference.com/w/cpp/language/lambda</a></li>
  <li><a href="http://en.cppreference.com/w/cpp/utility/functional/function">http://en.cppreference.com/w/cpp/utility/functional/function</a></li>
</ul>

</div>

<div class="related">
  <h2>Related Posts</h2>
  <ul class="related-posts">
    
      <li>
        <h3>
          <a href="/list-zipper-swift/">
            List Zipper applied to iOS swift
            <small>24 May 2019</small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/what-is-wrong-with-the-object-paradigm/">
            What is wrong with the object paradigm ?
            <small>17 Feb 2017</small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/boost-property-tree/">
            How to use boost::property_tree to load and write JSON
            <small>21 Dec 2015</small>
          </a>
        </h3>
      </li>
    
  </ul>
</div>

    </div>

    
    <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-10762787-1', 'auto');
    ga('send', 'pageview');
</script>
    

    <footer class="footer">
  <hr/>
  <div class="container">
    <div class="row">
      <p class="text-muted col-sm-10 text-center">
            <span class="sidebar-nav-item small">Make a donation. üòá</span>
            <span class="sidebar-nav-item x-small">BTC: <a href="bitcoin:1JcME7DSCw8b83nEGFKUYTKE4LM8aX4dhJ">1JcME7DSCw8b83nEGFKUYTKE4LM8aX4dhJ</a></span>
            <span class="sidebar-nav-item x-small">ETH: <a href="ethereum:eA22ADf19f20D618D8EF66E4704C540A10708F1F">eA22ADf19f20D618D8EF66E4704C540A10708F1F</a></span>
      </p>
      <p class="col-sm-2">
        <a class="twitter-share-button col-sm"
           href="https://twitter.com/share"
           data-via="Zenol42">
          Tweet
        </a>
      </p>
    </div>
  </div>
</footer>

<!-- Bootstrap core JavaScript
================================================== -->
<!-- Placed at the end of the document so the pages load faster -->
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="/bootstrap/js/vendor/jquery.min.js"><\/script>')</script>
<script src="/public/bootstrap/js/bootstrap.min.js"></script>

<!-- Twitter sharing button loader -->
<script>
  window.twttr = (function(d, s, id) {
    var js, fjs = d.getElementsByTagName(s)[0],
      t = window.twttr || {};
    if (d.getElementById(id)) return t;
    js = d.createElement(s);
    js.id = id;
    js.src = "https://platform.twitter.com/widgets.js";
    fjs.parentNode.insertBefore(js, fjs);

    t._e = [];
    t.ready = function(f) {
      t._e.push(f);
    };

    return t;
  }(document, "script", "twitter-wjs"));
</script>

  </body>
</html>
