<!DOCTYPE html>
<html lang="en-us">

  <head>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <meta name="description" content="Jeremy Cochoy's personal website.">
  <meta name="author" content="Jeremy Cochoy">

  <title>
    
      Haskell - Lazy IO &middot; Jeremy Cochoy
    
  </title>

  <!-- CSS -->
  <link href="/public/bootstrap/css/bootstrap.min.css" rel="stylesheet">
  <link rel="stylesheet" href="/public/css/poole.css">
  <link rel="stylesheet" href="/public/css/syntax.css">
  <link rel="stylesheet" href="/public/css/hyde.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">
  <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
  <!--[if lt IE 9]>
  	<script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
  	<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
	<![endif]-->

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/apple-touch-icon-precomposed.png">
  <link rel="shortcut icon" href="/public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">

  <!-- Custom styles for this template -->
  <link href="/public/style.css" rel="stylesheet">

  <!-- Maths equations -->
  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$','$'], ['\\(','\\)']],
      processEscapes: true
    }
  });
  </script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
</head>


  <body>

    <!-- Fixed navbar -->
<nav class="navbar navbar-default navbar-fixed-top">
 <div class="container">
   <div class="navbar-header">
     <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
 <span class="sr-only">Toggle navigation</span>
 <span class="icon-bar"></span>
 <span class="icon-bar"></span>
 <span class="icon-bar"></span>
     </button>
     <a class="navbar-brand" href="/">Jeremy Cochoy</a>
   </div>
   <div id="navbar" class="collapse navbar-collapse">
     <ul class="nav navbar-nav">
     <li><a href="/resume/">Resume</a></li>
 <li><a href="/blog/">Blog</a></li>
 <li role="separator" class="divider"></li>
 <li><a href="/talks/">Talks</a></li>
 <li><a href="/research/">Research</a></li>
 <li><a href="/teaching/">Teaching</a></li>
 <li><a href="/music/">Music</a></li>
 <li class="dropdown">
   <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">More <span class="caret"></span></a>
   <ul class="dropdown-menu">
     <li><a href="/hyper-flop/">Hyper-Flop</a></li>
     <li role="separator" class="divider"></li>
     <li><a href="/pdfs/">PDFs & Talks</a></li>
     <li><a href="/agreg-dev/">Agregation de mathématique</a></li>
     <li role="separator" class="divider"></li>
     <li><a href="https://github.com/jeremycochoy/sednl" alt="SEDNL Github">SEDNL (Github)</a></li>
     <li><a href="http://sednl.zenol.fr" alt="Simple Event Driven Network Library">SEDNL</a></li>
           <li role="separator" class="divider"></li>
           <li><a href="/gb-doc">GameBoy Emulator Documentation</a></li>
   </ul>
 </li>
     </ul>
   </div><!--/.nav-collapse -->
 </div>
</nav>


    <div class="container">
      <div class="post">
  <h1 class="post-title">Haskell - Lazy IO</h1>
  <span class="post-date">16 Jul 2013</span>
  <p>Ces derniers jours, j’écrivais un script haskell qui repère les fichiers présent en double, et propose de ne conserver qu’un exemplaire. Très pratique pour faire un peu de rangement, par exemple parmi une centaine de PDF que je ne lirais jamais.</p>

<p>Je vais ici vous parler de la phase de hachage des fichiers pour les trier et déterminer les doublons. Et oui, on ne vas pas comparer le contenu de tous les fichiers entre eux, ça serait en n^2 par rapport au nombre de fichiers. On ne veux pas non plus attendre une journée.</p>

<p>Je parlerais donc de la lecture du contenu des fichiers pour produire leur hash. Le trie des paires (Nom du fichier, hash) et l’affichage étant trivial et sans intérêt.</p>

<h1 id="strict-io-">Strict IO ?</h1>

<p>La première approche est souvent la plus simple. Nous voulons le hash d’un fichier? Et bien il suffit d’utiliser la fonction <code class="language-plaintext highlighter-rouge">hash :: String -&gt; ByteString</code> du package <code class="language-plaintext highlighter-rouge">Crypto.Hash.SHA1</code> (SHA1, MD5, MD4, SHA256 … celons vos gouts). Pour obtenir le contenue du fichier, on peux utiliser <code class="language-plaintext highlighter-rouge">readFile :: FilePath -&gt; IO String</code>.</p>

<p>Cela nous donne :</p>
<pre><code class="language-{.haskell}">getHash :: String -&gt; (String, ByteString)
getHash filename = do
    hashed &lt;- fmap hash $ readFile filename
    return (filename, hashed)
</code></pre>

<p>Il suffit alors d’appliquer <code class="language-plaintext highlighter-rouge">mapM getHash</code> sur une liste de nom de fichier pour obtenir une liste de couple Nomdufichier/Hashdufichier.</p>

<p>Si l’on test, cela fonctionne très bien… jusqu’au moment où vous tombez sur un fichier de plus d’1GO. Là, <code class="language-plaintext highlighter-rouge">readFile</code> veux charger l’intégralité du fichier en mémoire. Et bien-sur, sur ma machine, c’est impossible.</p>

<h1 id="la-paresse-a-la-rescousse">La paresse a la rescousse!</h1>

<p>On vous à toujours dis qu’être paresseux, c’était mal, improductif, et vous mènerais à votre perte? Et bien, ils avaient tort.</p>

<p>On voudrais lire le fichier par morceau, et construire le hash avec ces morceaux (ce que toute bonne fonction de hachage permet).</p>

<p>Pour ce qui est du hachage, on trouve dans <code class="language-plaintext highlighter-rouge">Crypto.Hash.Whatever</code> les trois fonctions :</p>
<pre><code class="language-{.haskell}">init :: Ctx
update :: Ctx -&gt; S.ByteString -&gt; Ctx
finalize :: Ctx -&gt; S.ByteString
</code></pre>

<p>Il nous faut donc un flux de <code class="language-plaintext highlighter-rouge">ByteString</code>. Pour ce faire, on dispose d’une version paresseuse de <code class="language-plaintext highlighter-rouge">ByteString</code>, qui se trouve dans le package <code class="language-plaintext highlighter-rouge">Data.ByteString.Lazy</code>. Histoire de fixer les notations et de ne pas se perdre entre les <code class="language-plaintext highlighter-rouge">ByteString</code> strict et les <code class="language-plaintext highlighter-rouge">ByteString</code> lazy, on parlera respectivement de <code class="language-plaintext highlighter-rouge">S.ByteString</code> et de <code class="language-plaintext highlighter-rouge">L.ByteString</code> (Strict/Lazy).</p>

<p>Cela revient a importer les deux types de la façon suivante :</p>
<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">import</span> <span class="k">qualified</span> <span class="nn">Data.ByteString</span> <span class="k">as</span> <span class="n">S</span>
<span class="kr">import</span> <span class="k">qualified</span> <span class="nn">Data.ByteString.Lazy</span> <span class="k">as</span> <span class="n">L</span>
</code></pre></div></div>

<p>Le type L.ByteString est en fait une liste de S.ByteString, et chaque bloc ne sera lu depuis le fichier qu’au moment où il sera utilisé. Le module L nous offre donc gentiment les fonctions</p>
<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">L</span><span class="o">.</span><span class="n">readFile</span> <span class="o">::</span> <span class="kt">FilePath</span> <span class="o">-&gt;</span> <span class="kt">IO</span> <span class="kt">L</span><span class="o">.</span><span class="kt">ByteString</span>
<span class="kt">L</span><span class="o">.</span><span class="n">foldlChunks</span> <span class="o">::</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">S</span><span class="o">.</span><span class="kt">ByteString</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">L</span><span class="o">.</span><span class="kt">ByteString</span> <span class="o">-&gt;</span> <span class="n">a</span>
</code></pre></div></div>

<p>La première nous donne le contenue de notre fichier. La seconde, nous offre exactement la méthode qui “prend une fonction ajoutant un morceau de fichier au hash”, puis “un hash vide”, et enfin “une ByteString paresseuse”. Cela parais plus évident si l’on spécialise les “a” en “Ctx”.</p>

<p>On peux donc utiliser :</p>
<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">hashed</span> <span class="o">&lt;-</span> <span class="n">fmap</span> <span class="p">(</span><span class="n">finalize</span> <span class="o">.</span> <span class="n">foldlChunks</span> <span class="n">update</span> <span class="n">init</span><span class="p">)</span> <span class="o">$</span> <span class="n">readFile</span> <span class="n">filename</span>
</code></pre></div></div>

<p>Bon, en fait, il y avais plus simple. Il y a aussi la fonction :</p>
<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">hashlazy</span> <span class="o">::</span> <span class="kt">L</span><span class="o">.</span><span class="kt">ByteString</span> <span class="o">-&gt;</span> <span class="kt">S</span><span class="o">.</span><span class="kt">ByteString</span>
</code></pre></div></div>
<p>qui produit le même résultat que notre pli.</p>

<p>Et là tout fonctionne bien, nos fichier d’1Go sont haché.</p>

<p>Mais … si vous travaillez sur beaucoup de fichiers, vous risquez d’avoir un soucis. Par exemple, si vous testez sur <code class="language-plaintext highlighter-rouge">/usr/lib</code>, vous obtiendrez peut-être une jolie exception vous indiquant qu’il y a trop de filedescriptors utilisés, et que donc le fichier ne peux être ouvert.
Il se trouve que les fichier ne sont pas fermé immédiatement après le hachage, et c’est un vrai problème. Problème que nous allons résoudre.</p>

<h1 id="la-solution--withfile">La solution : withFile</h1>

<p>La fonction <code class="language-plaintext highlighter-rouge">withFile :: FilePath -&gt; IOMode -&gt; (Handle -&gt; IO r) -&gt; IO r</code> est la clef. Cette fonction prend un nom de fichier, le mode d’ouverture (on utilisera ReadMode), une fonction qui travaille sur le fichier, et nous fait suivre le résultat de l’application de cette fonction. Un peu stupide, me direz vous? Et bien, ça le serait, si cette fonction se contenter de ça. En fait, elle vous assure aussi qu’une fois évaluée, le fichier est fermé. En l’utilisant, on est donc certain que le fichier est immédiatement fermé lorsque withFile est évalué en un “IO r”.</p>

<pre><code class="language-`haskell">getHash filename = do
    hashed &lt;- withFile filename ReadMode $ \h -&gt; do
        fmap hashLazy $ L.hGetContents h
return (filename, hashed)
</code></pre>

<p>Le <code class="language-plaintext highlighter-rouge">unefonction $ \h -&gt; do</code> est une pratique courante pour ces fonctions qui évalue un morceau de code dans un certains contexte. C’est très pratique, et on reconnaît très vite cette idiome avec un peu d’entraînement.</p>

<p>On compile pour vérifier le typage, tout vas bien, et l’on lance donc notre application que l’on s’attend a voir fonctionner. Et là, c’est le drame : “Illegal operation : handle is closed”.</p>

<p>Wohw, quel est ce mystérieux message? Et bien, comme je vous l’ai dit, withFile ferme immédiatement le fichier après l’évaluation de son expression. Et que fait son évaluation? Elle retourne le hash du fichier me dite vous? Faut.</p>

<p>La fonction construit un thunk (je parlerais de promesse de calcul, ou plus simplement de promesse) a l’aide de “fmap …”. L’évaluation de withFile retourne alors cette promesse, plutôt que la valeur du hash. Et cette promesse, elle, ne sera évaluée que plus tard, au moment ou vous en aurez vraiment besoin, et seulement si vous en avez besoin.</p>

<p>Il nous faut donc forcer haskell a être strict, et évaluer le hash avant de sortir de la fonction. Il y a différentes façons de le faire. La plus simple, c’est d’utiliser l’opérateur <code class="language-plaintext highlighter-rouge">`seq`</code> qui force l’évaluation de l’expression a sa gauche, puis retourne l’expression a sa droite. On a aussi l’opérateur <code class="language-plaintext highlighter-rouge">a ($!) b = b `seq` (a b)</code> qui est une “application stricte”. C’est a dire que ce qui sera a droite de <code class="language-plaintext highlighter-rouge">$!</code> sera évalué.</p>

<p>Nb : Il faut faire attention. Quand je dis évalué, je parle bien de <em>dé-construire</em> le premier niveau de l’expression. C’est a dire que si <code class="language-plaintext highlighter-rouge">compute 1 42</code> est un calcul, ceci sera remplacer par la promesse ou le résultat retournée par compute. Si compute produit une promesse plutôt qu’un résultat, l’opérateur <code class="language-plaintext highlighter-rouge">`seq`</code> n’évaluera pas la promesse. Il existe un opérateur <code class="language-plaintext highlighter-rouge">`deepSeq`</code>, qui lui vas <em>tout réduire</em> en profondeur. Comme vous vous en doutez, c’est très coûteux et évalue des choses dont on n’auras peut-être pas besoin. Le plus souvent, on peux se contenter de <code class="language-plaintext highlighter-rouge">`seq`</code> appliqué au bonne endroit pour obtenir le résultat souhaité.</p>

<p>Dans notre cas, il faudrait forcer la promesse faire par <code class="language-plaintext highlighter-rouge">fmap</code> a être évaluée, puis la promesse faite par <code class="language-plaintext highlighter-rouge">hashlazy</code>. Vous allez voir que la solution n’est pas plus compliquée que ce que nous avions déjà écrit :</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- getHash ...</span>
    <span class="n">withFile</span> <span class="n">filename</span> <span class="kt">ReadMode</span> <span class="o">$</span> <span class="nf">\</span><span class="n">h</span> <span class="o">-&gt;</span> <span class="kr">do</span>
        <span class="c1">-- On obtient la promesse faite par hashlazy</span>
        <span class="kr">data</span> <span class="o">&lt;-</span> <span class="n">fmap</span> <span class="n">hashlazy</span> <span class="o">$</span> <span class="n">hGetContents</span> <span class="n">h</span>
        <span class="c1">-- On force l'évaluation de hashlazy, qui donc sera forcé d'ouvrir le fichier et de le lire, puisque la valeur retournée est un S.ByteString, une valeur Stricte.</span>
        <span class="n">return</span> <span class="o">$!</span> <span class="kr">data</span>
</code></pre></div></div>

<p>Voila, c’est tout, c’est <code class="language-plaintext highlighter-rouge">$!</code> qui fait tout le travail en demandant à hashlazy de gentiment s’évaluer.</p>

<p>Et la c’est le bonheur, tout refonctionne et l’on peux gérer des fichiers arbitrairement grand en nombre arbitrairement grand, le tout en 4 lignes.</p>

</div>

<div class="related">
  <h2>Related Posts</h2>
  <ul class="related-posts">
    
      <li>
        <h3>
          <a href="/list-zipper-swift/">
            List Zipper applied to iOS swift
            <small>24 May 2019</small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/what-is-wrong-with-the-object-paradigm/">
            What is wrong with the object paradigm ?
            <small>17 Feb 2017</small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/boost-property-tree/">
            How to use boost::property_tree to load and write JSON
            <small>21 Dec 2015</small>
          </a>
        </h3>
      </li>
    
  </ul>
</div>

    </div>

    
    <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-10762787-1', 'auto');
    ga('send', 'pageview');
</script>
    

    <footer class="footer">
  <hr/>
  <div class="container">
    <div class="row">
      <p class="text-muted col-sm-10 text-center">
            <span class="sidebar-nav-item small">Make a donation. 😇</span>
            <span class="sidebar-nav-item x-small">BTC: <a href="bitcoin:1JcME7DSCw8b83nEGFKUYTKE4LM8aX4dhJ">1JcME7DSCw8b83nEGFKUYTKE4LM8aX4dhJ</a></span>
            <span class="sidebar-nav-item x-small">ETH: <a href="ethereum:eA22ADf19f20D618D8EF66E4704C540A10708F1F">eA22ADf19f20D618D8EF66E4704C540A10708F1F</a></span>
      </p>
      <p class="col-sm-2">
        <a class="twitter-share-button col-sm"
           href="https://twitter.com/share"
           data-via="Zenol42">
          Tweet
        </a>
      </p>
    </div>
  </div>
</footer>

<!-- Bootstrap core JavaScript
================================================== -->
<!-- Placed at the end of the document so the pages load faster -->
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="/bootstrap/js/vendor/jquery.min.js"><\/script>')</script>
<script src="/public/bootstrap/js/bootstrap.min.js"></script>

<!-- Twitter sharing button loader -->
<script>
  window.twttr = (function(d, s, id) {
    var js, fjs = d.getElementsByTagName(s)[0],
      t = window.twttr || {};
    if (d.getElementById(id)) return t;
    js = d.createElement(s);
    js.id = id;
    js.src = "https://platform.twitter.com/widgets.js";
    fjs.parentNode.insertBefore(js, fjs);

    t._e = [];
    t.ready = function(f) {
      t._e.push(f);
    };

    return t;
  }(document, "script", "twitter-wjs"));
</script>

  </body>
</html>
