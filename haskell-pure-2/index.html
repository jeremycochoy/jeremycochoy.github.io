<!DOCTYPE html>
<html lang="en-us">

  <head>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <meta name="description" content="Jeremy Cochoy's personal website.">
  <meta name="author" content="Jeremy Cochoy">

  <title>
    
      Le Haskell, un langage au label pure. Seconde partie. &middot; Jeremy Cochoy
    
  </title>

  <!-- CSS -->
  <link href="/public/bootstrap/css/bootstrap.min.css" rel="stylesheet">
  <link rel="stylesheet" href="/public/css/poole.css">
  <link rel="stylesheet" href="/public/css/syntax.css">
  <link rel="stylesheet" href="/public/css/hyde.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">
  <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
  <!--[if lt IE 9]>
  	<script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
  	<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
	<![endif]-->

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/apple-touch-icon-precomposed.png">
  <link rel="shortcut icon" href="/public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">

  <!-- Custom styles for this template -->
  <link href="/public/style.css" rel="stylesheet">

  <!-- Maths equations -->
  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$','$'], ['\\(','\\)']],
      processEscapes: true
    }
  });
  </script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
</head>


  <body>

    <!-- Fixed navbar -->
<nav class="navbar navbar-default navbar-fixed-top">
 <div class="container">
   <div class="navbar-header">
     <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
 <span class="sr-only">Toggle navigation</span>
 <span class="icon-bar"></span>
 <span class="icon-bar"></span>
 <span class="icon-bar"></span>
     </button>
     <a class="navbar-brand" href="/">Jeremy Cochoy</a>
   </div>
   <div id="navbar" class="collapse navbar-collapse">
     <ul class="nav navbar-nav">
 <li><a href="/blog/">Blog</a></li>
 <li><a href="/resume/">Resume</a></li>
 <li role="separator" class="divider"></li>
 <li><a href="/research/">Research</a></li>
 <li><a href="/talks/">Talks</a></li>
 <li><a href="/teaching/">Teaching</a></li>
 <li><a href="/music/">Music</a></li>
 <li class="dropdown">
   <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">More <span class="caret"></span></a>
   <ul class="dropdown-menu">
     <li><a href="/hyper-flop/">Hyper-Flop</a></li>
     <li role="separator" class="divider"></li>
     <li><a href="/pdfs/">PDFs & Talks</a></li>
     <li><a href="/agreg-dev/">Agregation de mathÃ©matique</a></li>
     <li role="separator" class="divider"></li>
     <li><a href="https://github.com/jeremycochoy/sednl" alt="SEDNL Github">SEDNL (Github)</a></li>
     <li><a href="http://sednl.zenol.fr" alt="Simple Event Driven Network Library">SEDNL</a></li>
           <li role="separator" class="divider"></li>
           <li><a href="/gb-doc">GameBoy Emulator Documentation</a></li>
   </ul>
 </li>
     </ul>
   </div><!--/.nav-collapse -->
 </div>
</nav>


    <div class="container">
      <div class="post">
  <h1 class="post-title">Le Haskell, un langage au label pure. Seconde partie.</h1>
  <span class="post-date">22 Apr 2013</span>
  <p>Nous continuons de dÃ©couvrir des paysages fonctionnels Ã  travers le Haskell. Cette fois, nous nous Ã©loignons des gÃ©nÃ©ralitÃ©s et rentrons dans le vif du sujet en nous intÃ©ressant Ã  des aspects plus propre au haskell (bien que dâ€™autres langages fonctionnels implÃ©mentent des fonctionnalitÃ©s similaires).</p>

<p>La <a href="/haskell-pure-1/" title="Le Haskell, un langage au label pure. PremiÃ¨re partie.">premiÃ¨re partie est disponible ici</a>. La <a href="/haskell-pure-3/" title="Le Haskell, un langage au label pure. TroisiÃ¨me partie.">troisiÃ¨me lÃ </a>.</p>

<h2 id="la-force-de-haskell">La force de haskell</h2>

<h3 id="les-listes-infinies-et-listes-en-comprÃ©hension">Les listes infinies (et listes en comprÃ©hension)</h3>

<p>Les listes infinies sont une des nombreuses possibilitÃ©s offertes par un langage paresseux. Câ€™est souvent dâ€™elles dont on entend le plus parler pour prÃ©senter le haskell, alors quâ€™il ne sâ€™agit pourtant que dâ€™une fonctionnalitÃ© original parmi tant dâ€™autres. Cela est sÃ»rement du au fait que la notion dâ€™infinie Ã©veille la curiositÃ© des dÃ©veloppeurs habituÃ© Ã  un monde impÃ©ratif oÃ¹ les tableaux, les listes, et toute structure mÃ©moire est finie.</p>

<p>Le principe est relativement simple : vous dÃ©finissez une liste, que ce soit de faÃ§on rÃ©cursive ou simplement par comprÃ©hension (on vas voir ce que cela signifie dans quelques lignes), puis seulement les Ã©lÃ©ments de la liste dont le programme auras besoin seront Ã©valuÃ©. Les autres ne seront jamais calculÃ©s.</p>

<p>Comment faire de telles listes? La faÃ§on la plus simple est la dÃ©finition de liste par comprÃ©hension, câ€™est Ã  dire une dÃ©finition de la forme â€œLâ€™ensemble des f(trucs) pour les quels P(truc) est vraieâ€. OÃ¹ f est une formule sur â€œtrucsâ€ et oÃ¹ P est une proposition, disons une fonction qui renvoie True ou False.</p>

<p>Par exemple :</p>
<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- "x &lt;- l" signifit "pour x se baladant dans la liste l"</span>
<span class="c1">-- l1 = [1, 2, 3, 4, 5]</span>
<span class="n">l1</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="o">|</span> <span class="n">x</span> <span class="o">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]]</span>
<span class="c1">-- L'opÃ©rateur c/c++ != s'Ã©crit /= </span>
<span class="c1">-- l2 = [1, 2, 4, 5]</span>
<span class="n">l2</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="o">|</span> <span class="n">x</span> <span class="o">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="n">x</span> <span class="o">/=</span> <span class="mi">3</span><span class="p">]</span>

<span class="c1">-- l3 = [2, 4, 8, 16, 32]</span>
<span class="n">l2</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="o">^</span><span class="n">x</span> <span class="o">|</span> <span class="n">x</span> <span class="o">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]]</span>

<span class="c1">-- l4 = [2, 4, 16, 32]</span>
<span class="n">l4</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="o">^</span><span class="n">x</span> <span class="o">|</span> <span class="n">x</span> <span class="o">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="n">x</span> <span class="o">/=</span> <span class="mi">3</span><span class="p">]</span>
</code></pre></div></div>

<p>En fait, câ€™est une sorte de sucre syntaxique. Le soucis, câ€™est que ce que cache les listes en comprÃ©hension ne seras aborder que dans la troisiÃ¨me partie. On se contenteras donc de la signification et de la faÃ§on dont on lâ€™utilise.</p>

<p>Pour en revenir a nos listes en comprÃ©hension infinie, on peut penser Ã  â€œLâ€™ensemble des entiers qui sont paireâ€ par exemple. Voici quelques listes infinies :</p>
<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">--La liste de tous les entiers Ã  partir de 42 peut s'Ã©crire [42..]</span>
<span class="n">liste_infinie_des_entiers</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">]</span>

<span class="c1">--Pour calculer x % 2 (c/c++), on Ã©crit "x `mod` 2", ou encore "mod x 2".</span>

<span class="n">liste_des_entiers_paires</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">x</span> <span class="o">|</span> <span class="n">x</span> <span class="o">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">]]</span>
<span class="c1">-- On peut rajouter des conditions sÃ©parÃ© par des virgules</span>
<span class="n">liste_des_entiers_paires'</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="o">|</span> <span class="n">x</span> <span class="o">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">],</span> <span class="n">x</span> <span class="p">`</span><span class="n">mod</span><span class="p">`</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span>

<span class="c1">-- On peut utiliser plusieurs variables se baladant dans diffÃ©rentes listes :</span>
<span class="n">liste_de_produit</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="o">*</span> <span class="n">y</span> <span class="o">|</span> <span class="n">x</span> <span class="o">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">],</span> <span class="n">y</span> <span class="o">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">]]</span>
</code></pre></div></div>

<p>Une autre faÃ§on de dÃ©finir une liste est dâ€™utiliser la rÃ©cusivitÃ©. Voici quelques exemples.</p>
<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">--"map f l" applique la fonction f sur chaque Ã©lÃ©ment de la liste l</span>
<span class="c1">-- [a, b] est du sucre syntaxique pour a : b : [].</span>
<span class="n">entiers</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">:</span> <span class="p">(</span><span class="n">map</span> <span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="p">)</span> <span class="n">entiers</span><span class="p">)</span>
</code></pre></div></div>

<p>Regardons se qui se passe si lâ€™on demande les trois premiers Ã©lÃ©ments de la liste, ce qui se fait avec <code class="highlighter-rouge">take 3 l</code>. Dâ€™abord, il lit <code class="highlighter-rouge">1 :</code> et connais donc le premier Ã©lÃ©ment. Pour avoir le second, il lit <code class="highlighter-rouge">(map (1+) entiers)</code>. Il applique donc map sur la liste, mais de faÃ§on paresseuse, câ€™est a dire quâ€™en ne calculant que lâ€™application sur le premier terme. Il obtient donc <code class="highlighter-rouge">(1+)(1) = 2</code>. puis, pour avoir le troisiÃ¨me Ã©lÃ©ment, il doit appliquer <code class="highlighter-rouge">(1+)</code> au deuxiÃ¨me Ã©lÃ©ment de la liste entier. Ã‡a tombe bien, on vient de le calculer, câ€™est <code class="highlighter-rouge">2</code>. On a donc pour troisiÃ¨me Ã©lÃ©ment <code class="highlighter-rouge">(1+)(2) = 3</code>.</p>

<p>De cette faÃ§on, on aurais aussi pu dÃ©finir la liste des entiers pairs, la liste des nombres de fibonacci (mÃªme si on ne voit pas bien lâ€™intÃ©rÃªt dans un programme), ou la liste des nombres premiers (plus difficile).</p>

<p>Bon, câ€™est trÃ¨s beau tout Ã§a, mais est-ce que Ã§a sert vraiment (parce que, faire des listes infinies pour faire des listes infiniesâ€¦)? Oui, Ã§a sert, et voici un exemple simple et concret. Disons que vous participez au Google Code Jam. Vous devez fournir des rÃ©ponse en respectant un certain format. Plus prÃ©cisÃ©ment, on vous donne une entrÃ©e de n Ã©lÃ©ments Ã  traiter, par exemple n lignes contenant chacune un nombre, et vous devez fournir le rÃ©sultat de votre traitement sous la forme _Case #i: <vos donnÃ©es="">\n_. En C++, on aurais itÃ©rÃ© sur la liste de rÃ©sultat (ou directement l'entrÃ©e) et provoquÃ© l'Ã©criture de "Case #i" sur la sortie standard juste avant celle de vos donnÃ©es. En haskell, on peut (doit?) faire Ã§a diffÃ©remment (J'ai honteusement pompÃ© ce que propose un dÃ©veloppeur sur [youtube](http://www.youtube.com/watch?v=_tgv3HVgOMc)) :</vos></p>
<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">boilerPlate</span> <span class="o">::</span> <span class="p">[</span><span class="kt">String</span><span class="p">]</span>
<span class="n">boilerPlate</span> <span class="o">=</span> <span class="p">[</span><span class="s">"Case #"</span> <span class="o">++</span> <span class="n">show</span> <span class="n">n</span> <span class="o">++</span> <span class="s">": "</span> <span class="o">|</span> <span class="n">n</span> <span class="o">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">]]</span>

<span class="n">standardOutput</span> <span class="o">::</span> <span class="p">[</span><span class="kt">String</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="kt">String</span><span class="p">]</span>
<span class="c1">-- zipWith f l1 l2 recole les deux listes l1 et l2 en utilisant la fonction f sur les Ã©lÃ©ments de chacune des deux listes.</span>
<span class="c1">-- La liste produite par zipWith fait la longueur de la plus courte.</span>
<span class="c1">-- Par exemple, zipWith (+) [1, 2, 3] [1, 1, 1, 1, 1] = [1+1, 2+1, 3+1]</span>
<span class="n">standardOutput</span> <span class="o">=</span> <span class="n">zipWith</span> <span class="p">(</span><span class="o">++</span><span class="p">)</span> <span class="n">boilerPlate</span>

<span class="c1">-- Une fois votre sortie sous la forme d'une liste de String, il vous suffit de la donner Ã  standardOutput pour obtenir le formatage attendu</span>
</code></pre></div></div>

<p>On voit ici que la liste infinie boilerPlate contient tous les formatages possibles. Bien entendu, Ã  chaque exÃ©cution, il nâ€™y auras quâ€™un nombre finie dâ€™entrÃ©es et de sorties, donc une partie finie de la liste qui seras utilisÃ©.</p>

<h3 id="data-driven-programming">Data-driven programming</h3>

<p>En haskell, manipuler des listes ou des structures similaires est chose courante, et il y a un bon nombre de fonction dÃ©diÃ©s. Par exemple <code class="highlighter-rouge">map f l</code> qui permet dâ€™appliquer <code class="highlighter-rouge">f</code> sur les Ã©lÃ©ments de <code class="highlighter-rouge">l</code>, <code class="highlighter-rouge">zip</code> et <code class="highlighter-rouge">zipWith</code> qui permettent de souder deux liste en une unique (soit sous forme de liste de couple, soit en utilisant la fonction que vous fournissez). Mais ce nâ€™est pas tout. Nous ne parlerons par exemple pas de <code class="highlighter-rouge">foldr</code> et <code class="highlighter-rouge">foldl</code> qui permettent a partir dâ€™une liste dâ€™Ã©lÃ©ments de lâ€™Ã©craser en un nouvel Ã©lÃ©ment grÃ¢ce Ã  une fonction que vous fournissez (leurs usages est multiple. On peut implÃ©menter facilement la somme/produit des Ã©lÃ©ments dâ€™une liste, la conversion dâ€™une liste de mot en une seul chaine de caractÃ¨re, la transformation dâ€™une liste en un arbre binaire de recherche, etc).</p>

<p>Vous devriez avoir remarquer quâ€™en haskell, on aime bien concevoir de petites fonctions travaillant sur un Ã©lÃ©ment de type a, et produisant un Ã©lÃ©ment de type b, puis appliquer ces petites fonctions sur les Ã©lÃ©ments de structures de donnÃ©s plus ou moins complexe. Cela a de nombreux avantages :
-Il est plus simple de concevoir une fonction de type Int-&gt;String quâ€™une fonction de type <code class="highlighter-rouge">[Int] -&gt; [(String, Int)]</code>, par exemple.
-On est plus gÃ©nÃ©rique ; Si lâ€™on sais transformer du a en b, alors on sais transformer du <code class="highlighter-rouge">[a]</code> en <code class="highlighter-rouge">[b]</code> et du <code class="highlighter-rouge">Tree a</code> en <code class="highlighter-rouge">Tree b</code> (oÃ¹ <code class="highlighter-rouge">Tree a</code> est un arbre binaire oÃ¹ chaque noeud contient un Ã©lÃ©ment de type a).
-En cas de changement de structure mÃ©moire, par exemple pour des raisons de performances, on minimise lâ€™impacte sur le code Ã  modifier. Si lâ€™on souhaite passer de liste Ã  des arbres, seul le traitement effectuÃ© sur les listes devras Ãªtre rÃ©-Ã©crit pour les arbres, mais rien dâ€™autre.</p>

<p>On se retrouve donc Ã  se concentrer plus sur les types quâ€™on manipule que la faÃ§on dont on les manipule. Câ€™est Ã  dire que lâ€™on dispose dâ€™un nombre important de faÃ§on simple de transformer certaines donnÃ©es en dâ€™autres, et les points cruciaux sont alors de:
-Bien choisir la faÃ§on dont seront reprÃ©sentÃ©s les donnÃ©es traitÃ©es
-Trouver les structures de donnÃ©es intermÃ©diaires au cours du dÃ©roulement dâ€™un algorithme.</p>

<p>Si lâ€™on sais exactement de quels donnÃ©s lâ€™on part, et quels donnÃ©s on droit produire, il ne reste alors plus quâ€™Ã  dÃ©crire les transformations nÃ©cessaire pour passer de lâ€™une Ã  lâ€™autre. Par exemple, faire un programme de reconnaissance de caractÃ¨re, câ€™est simplement transformer une image en une chaÃ®ne de caractÃ¨re. Pour peut que lâ€™on parvienne Ã  rÃ©duire lâ€™Ã©cart entre les structures de donnÃ©s considÃ©rÃ©s (par exemple une image, puis une liste de rectangles de pixels reprÃ©sentant des lignes, puis une liste de liste de rectangles de pixels reprÃ©sentant des mots) il devient trÃ¨s simple de dÃ©crire la transformation (on a rÃ©ussi a rÃ©duire le problÃ¨me a savoir dÃ©couper les lignes, dÃ©couper les mots, dÃ©couper les lettres puis reconnaÃ®tre une lettre).</p>

<p>Si ce type de raisonnement peut conduire Ã  du code catastrophique dans un langage objet, en haskell câ€™est trÃ¨s certainement lâ€™une des routes les plus sur. Tout, dans le langage, sâ€™adapte parfaitement Ã  cette conduite, et particuliÃ¨rement le systÃ¨me de types et de classes.</p>

<p>En C++ un type reprÃ©sente un ensemble de fonctionnalitÃ©s. En haskell un type nâ€™est rien dâ€™autre quâ€™un ensemble possible de valeur. On peut tout de fois prÃ©ciser quâ€™un type peut Ãªtre manipulÃ© dâ€™une certaine faÃ§on (ordonnÃ©, comparÃ©, affichÃ©â€¦). On pourrait dire que deux Ã©lÃ©ments dâ€™un type que lâ€™on a construit peuvent Ãªtre affichÃ©, ou encore comparÃ©, en le faisant instance dâ€™une classe. Cela correspond a la surcharge de fonctions/opÃ©rateurs du C++ ; aprÃ¨s avoir dÃ©clarer une structure <code class="highlighter-rouge">struct St;</code>, on peut surcharger lâ€™opÃ©rateur de comparaison pour ce nouveau type par <code class="highlighter-rouge">bool operator &lt; (St &amp;a, St &amp;b);</code>. Vient alors lâ€™idÃ©e de ce que doit Ãªtre quelque chose â€œdâ€™affichableâ€ ou de â€œcomparableâ€. Câ€™est un type pour le quel on doit avoir certaines fonctions de dÃ©finies. En java, il y Ã  la notion dâ€™interface, oÃ¹ lâ€™on veut imposer lâ€™existence de certaines mÃ©thodes. Malheureusement, on ne peut le faire que lors de la dÃ©claration dâ€™un type, et lâ€™implÃ©mentation de cette interface est faite â€œÃ  lâ€™intÃ©rieurâ€ du type. En haskell, pas de fonctions membres, mais des fonctions tout cours. Ce qui fait que nâ€™importe quel type pourra devenir instance de nâ€™importe quel classe (terme haskell dÃ©signant un jeu de fonctions) et Ã  lâ€™instant oÃ¹ vous le dÃ©sirerais. Le sens dâ€™une classe en haskell est donc plus proche de celle de la thÃ©orie des ensembles (une collection dâ€™objets [ici de types] qui respectent certaines conditions [ici, pouvoir Ãªtre comparÃ©, affichÃ©â€¦]) ou si vous voulait vraiment une analogie en langage impÃ©ratif, des interfaces du java. Ce nâ€™est certainement pas celui des classes C++.</p>

<p>Quand on prÃ©tend quâ€™un type est instance dâ€™une classe, on doit fournir lâ€™implÃ©mentation des fonctions de la classe, mais pas nÃ©cessairement toutes. Les classes fournissent souvent une implÃ©mentation des fonctions, souvent en terme rÃ©cursif. Par exemple on pourrais dÃ©finir a /= b Ã  partir de == et a == b Ã  partir de /=. De cette faÃ§on, il suffit de dÃ©finir lâ€™une des deux fonctions pour pouvoir immÃ©diatement utiliser les deux opÃ©rateurs. (Le compilateur sâ€™assurant que cela nâ€™engendre pas de sur-coÃ»t en terme de performances).</p>

<p>Voici par exemple la classe Eq, dÃ©crivant deux objets pouvant Ãªtre comparÃ© :</p>
<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">class</span>  <span class="kt">Eq</span> <span class="n">a</span>  <span class="kr">where</span>
<span class="kr">class</span> <span class="kt">Eq</span> <span class="n">a</span> <span class="kr">where</span>
    <span class="p">(</span><span class="o">==</span><span class="p">)</span> <span class="o">::</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Bool</span>
    <span class="p">(</span><span class="o">/=</span><span class="p">)</span> <span class="o">::</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Bool</span>
    <span class="n">x</span> <span class="o">==</span> <span class="n">y</span> <span class="o">=</span> <span class="n">not</span> <span class="p">(</span><span class="n">x</span> <span class="o">/=</span> <span class="n">y</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">/=</span> <span class="n">y</span> <span class="o">=</span> <span class="n">not</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">y</span><span class="p">)</span>
</code></pre></div></div>

<p>On rend un type instance dâ€™une classe de la faÃ§on suivante (exemple honteusement tirer de <em>Learn you haskell for a great good</em> :</p>
<pre><code class="language-haskel">data TrafficLight = Red | Yellow | Green

instance Eq TrafficLight where
    Red == Red = True
    Green == Green = True
    Yellow == Yellow = True
    _ == _ = False
</code></pre>
<p>On dÃ©finit lâ€™Ã©galitÃ© grÃ¢ce au filtrage par motif, en dÃ©finissant seulement lâ€™opÃ©rateur ==.</p>

<p>Bon, Ã  vrais dire, pour les classes comme Eq (comparable) et Show (affichable), on peut laisser haskell sâ€™en charger comme un grand :</p>
<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">data</span> <span class="kt">TrafficLight</span> <span class="o">=</span> <span class="kt">Red</span> <span class="o">|</span> <span class="kt">Yellow</span> <span class="o">|</span> <span class="kt">Green</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Eq</span><span class="p">)</span>
</code></pre></div></div>

<p>En fait, quand on parleras de foncteurs, foncteurs applicatifs ou monades, on parleras de type qui sont instance respectivement de Functor (Prelude.Functor), de Applicative (Control.Applicative) et de Monad (Control.Monad).</p>

<h3 id="les-foncteurs">Les foncteurs</h3>

<p>Les foncteurs (Ã  nouveau, le terme est Ã  prendre au sens e la thÃ©orie des catÃ©gories) constituent le point de dÃ©part vers les monades. Faisons un petit dÃ©tour par les maths et dÃ©finissons ce quâ€™est un foncteur (il nâ€™est pas nÃ©cessaire de comprendre ce paragraphe pour la suite, câ€™est pour la culture).</p>

<p><strong>La catÃ©gorie des types :</strong>_ Une catÃ©gorie $\mathcal{C}$ est une collection dâ€™ensembles. Ici, on regarderas la collection de tous les types hasell possible. Un ensemble seras donc un type. Ses Ã©lÃ©ments seront les valeurs qui sont de ce type. Par exemple Int seras un semble et 1, 4, 6 sont des Ã©lÃ©ments de cette ensemble. Il nâ€™y a que deux Ã©lÃ©ments dans lâ€™ensemble Bool, et une infinitÃ© dâ€™Ã©lÃ©ments pour Integer. Pour que ce soit une catÃ©gorie, il faut quâ€™Ã©tant donnÃ© deux ensembles de notre collection $A$ et $B$, il existes une ensemble dâ€™applications de $A \to B$. Dans notre cas ce seras toute les <em>fonctions</em> de type <i> A -&gt; B </i>. On parle des â€œflÃ¨ches de A vers Bâ€. Pour la culture, on note lâ€™ensemble de ces applications $Hom_{\mathcal{C}}(A, B)$.</p>

<p>Attention, pour que ce soit vraiment une catÃ©gorie, il faut quelques conditions sur ces flÃ¨ches :</p>

<p>1) Si $A$ est un Ã©lÃ©ment de $\mathcal{C}$, alors il faut que lâ€™identitÃ© soit une flÃ¨che. Dans notre cas, on veut que la fonction <code class="highlighter-rouge">id x = x</code> de type <code class="highlighter-rouge">A -&gt; A</code> soit bien une fonction haskell. Ce qui est le cas, puisque je viens de vous donner le code haskell qui permet de la dÃ©finir :)</p>

<p>2) Si $f: A \to B$ et $g : B \to C$ sont deux flÃ¨ches (respectivement de $A$ dans $B$ et de $B$ dans $C$), alors la composÃ© $g \circ f$ est une flÃ¨che de $A$ dans $C$. Dans le cas qui nous intÃ©resse, cette rÃ¨gle est bien respectÃ©e car si <code class="highlighter-rouge">f</code> et <code class="highlighter-rouge">g</code> sont deux fonctions haskell, alors la composÃ© est la fonction <code class="highlighter-rouge">\x -&gt; g (f x)</code>, que lâ€™on peut aussi Ã©crire <code class="highlighter-rouge">f . g</code>.</p>

<p>Donc, pour rÃ©sumer : La collection de tous les types haskell est une catÃ©gorie. Si <code class="highlighter-rouge">a</code> et <code class="highlighter-rouge">b</code> sont deux types haskell, lâ€™ensemble de toute les fonctions de <code class="highlighter-rouge">a -&gt; b</code> sont appelÃ©s les flÃ¨ches entre <code class="highlighter-rouge">a</code> et <code class="highlighter-rouge">b</code>.</p>

<p><strong>Les foncteurs (covariants) :</strong> Un foncteur $F$ dâ€™une catÃ©gorie $\mathcal{C}$ vers une catÃ©gorie $\mathcal{D}$ est :</p>

<p>1) Pour chaque semble $A$ de $\mathcal{C}$, un ensemble de $\mathcal{D}$ quâ€™on noteras $F(A)$.</p>

<p>2) Pour chaque flÃ¨che $f : A \to B$ entre des ensembles de $\mathcal{C}$, une flÃ¨che $F(A) \to F(B)$ quâ€™on noteras $F(f)$.</p>

<p>3) Il faut que $F(g \circ f) = F (g) \circ F(f)$ et que $F(id) = id$. Câ€™est Ã  dire que composer des flÃ¨ches avant transformation est la mÃªme chose que les composer aprÃ¨s, et lâ€™identitÃ© $id: A \to A$ (flÃ¨che qui ne fait rien) est bien envoyer sur lâ€™identitÃ© $id: F(A) -&gt; F(A)$.</p>

<p>Un foncteur est donc une faÃ§on de transformer une catÃ©gorie $\mathcal{C}$ en une partie (sous-catÃ©gorie) de $\mathcal{D}$.</p>

<p><strong>Point culture (pour les curieux) :</strong> Les foncteurs contravariants sont simplement des foncteurs qui â€œrenversentâ€ les flÃ¨ches, câ€™est Ã  dire en transforment A -&gt; B en F(A) &lt;- F(B).&lt;/i&gt;</p>

<p>Ici, ce qui nous intÃ©resse sont les foncteurs de $\mathcal{C}$ dans $\mathcal{C}$ (on dit des endofoncteurs). Ã€ partir de maintenant, on ne considÃ¨re plus que la catÃ©gorie $\mathcal{T}$ des types haskell. Un foncteur <code class="highlighter-rouge">Fonc</code>, en haskell, est un foncteur de $\mathcal{T}$ dans $\mathcal{T}$. Câ€™est Ã  dire :</p>

<p>1) Une faÃ§on Ã  tout type <code class="highlighter-rouge">a</code> dâ€™associer un type <code class="highlighter-rouge">Fonc a</code>. Ainsi <code class="highlighter-rouge">Fonc</code> est un constructeur de type, par exemple <code class="highlighter-rouge">Liste</code> ou <code class="highlighter-rouge">Arbre</code> des exemples prÃ©cÃ©dents. Câ€™est peut-Ãªtre le bon moment dâ€™aller feuilleter quelques lien sur les constructeurs de type et leur â€œkindâ€. Disons simplement quâ€™un type comme int ou bool est de kind <code class="highlighter-rouge">*</code> mais que Liste et Arbre sont de kind <code class="highlighter-rouge">* -&gt; *</code>. Cela signifit que ces deux dernier mangent un type <code class="highlighter-rouge">T</code> et fabrique des nouveaux types <code class="highlighter-rouge">Liste T</code> et <code class="highlighter-rouge">Arbre T</code>. Liste nâ€™est donc pas un type, mais un constructeur de type.</p>

<p>2) Une faÃ§on Ã  toute fonction <code class="highlighter-rouge">f :: a -&gt; b</code> dâ€™associer une fonction <code class="highlighter-rouge">f' :: Fonc a -&gt; Fonc b</code></p>

<p>3) Cette faÃ§on de faire doit transformer lâ€™identitÃ© <code class="highlighter-rouge">(\x -&gt; x) :: a -&gt; a</code> en lâ€™identitÃ© <code class="highlighter-rouge">(\x -&gt; x) :: Fonc a -&gt; Fonc a</code></p>

<p>4) Cette faÃ§on de faire doit passer Ã  la composition, câ€™est Ã  dire que si lâ€™on transforme <code class="highlighter-rouge">f :: a -&gt; b</code> en <code class="highlighter-rouge">f' :: Fonc a -&gt; Fonc b</code> et <code class="highlighter-rouge">g :: b -&gt; c</code> en <code class="highlighter-rouge">g' :: Fonc b -&gt; Fonc c</code>, alors ` g . f ` seras transformÃ© en <code class="highlighter-rouge">g' . f'</code>.</p>

<p>Pour quâ€™un constructeur de type <code class="highlighter-rouge">Fonc</code> soit un foncteur, on le fait instance de la classe Functor dÃ©finie comme suit :</p>
<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">class</span>  <span class="kt">Functor</span> <span class="n">f</span>  <span class="kr">where</span>
    <span class="n">fmap</span>        <span class="o">::</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">b</span>
</code></pre></div></div>

<p>Remarquez que lâ€™on peut lire <code class="highlighter-rouge">fmap :: (a -&gt; b) -&gt; (f a -&gt; f b)</code> ce qui signifie : fmap(fonctorial mapping) prend une fonction de type <code class="highlighter-rouge">a -&gt; b</code> et la transforme en une fonction de type <code class="highlighter-rouge">f a -&gt; f b</code>. On a donc bien une transformation dâ€™une flÃ¨che de a vers b en une flÃ¨che de $f a$ vers $f b$. Si lâ€™on a donc un constructeur de type qui est instance de <code class="highlighter-rouge">Functor</code>, on a bien un endofoncteur de la catÃ©gorie des types. Maintenant que nous avons le sentiment que toutes nos considÃ©rations thÃ©oriques nous ont apportÃ© une comprÃ©hension profonde du sujet, nous allons pouvoir les oublier et passer Ã  la pratique.</p>

<p>A quoi sert un foncteur : Un constructeur de type fonctoriel, câ€™est un constructeur de type oÃ¹ lâ€™on sauras maper des fonctions. Si notre type Liste devient instance de <code class="highlighter-rouge">Functor</code>, et que lâ€™on a un <code class="highlighter-rouge">Liste Int</code>, on peut construire rapidement une liste de tous ces nombres reprÃ©sentÃ© par des chaines de caractÃ¨res. Il suffit de disposer dâ€™une fonction <code class="highlighter-rouge">Int -&gt; String</code>. Haskell nous en fournis une, câ€™est <code class="highlighter-rouge">show</code>. Alors, on nâ€™a plus quâ€™a appliquer cette fonction sur chacun des Ã©lÃ©ments de la liste par <code class="highlighter-rouge">map show liste</code>.</p>

<p>Regardons comment rendre Liste instance de Functor :</p>
<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">instance</span>  <span class="kt">Functor</span> <span class="kt">Liste</span>  <span class="kr">where</span>
    <span class="n">fmap</span> <span class="n">f</span> <span class="kt">Vide</span> <span class="o">=</span> <span class="kt">Vide</span>
    <span class="n">fmap</span> <span class="n">f</span> <span class="p">(</span><span class="kt">Element</span> <span class="n">h</span> <span class="n">t</span><span class="p">)</span> <span class="o">=</span> <span class="kt">Element</span> <span class="p">(</span><span class="n">f</span> <span class="n">h</span><span class="p">)</span> <span class="p">(</span><span class="n">fmap</span> <span class="n">f</span> <span class="n">t</span><span class="p">)</span>

<span class="c1">-- Maintenant, on peut mapper des fonctions sur des listes</span>
<span class="n">estPositif</span> <span class="n">n</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>

<span class="n">listeEntiers</span> <span class="o">=</span> <span class="kt">Cons</span> <span class="mi">1</span> <span class="p">(</span><span class="kt">Cons</span> <span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">)</span> <span class="p">(</span><span class="kt">Cons</span> <span class="p">(</span><span class="o">-</span><span class="mi">30</span><span class="p">)</span> <span class="p">(</span><span class="kt">Cons</span> <span class="mi">4</span> <span class="kt">Vide</span><span class="p">)</span> <span class="p">)</span> <span class="p">)</span>
<span class="n">listeEstPositif</span> <span class="o">=</span> <span class="n">fmap</span> <span class="n">estPositif</span> <span class="n">listeEntiers</span>
<span class="c1">-- listeEstPositif = Cons True (Cons False (Cons False (Cons True Vide)))</span>
</code></pre></div></div>

<p>Si vous rÃ©flÃ©chissez bien, Ã§a ressemble beaucoup Ã  ce que vous faites Ã  chaque fois que vous appliquez un traitement aux Ã©lÃ©ments dâ€™un container ; vous parcourez une liste, et vous appliquez votre procÃ©dure Ã  chaque Ã©lÃ©ment. Lâ€™avantage dâ€™avoir une unique fonction fmap implÃ©mentÃ© pour chaque type, câ€™est que si vous dÃ©cidez de modifier votre container, vous nâ€™aurez que trÃ¨s peut de changement Ã  faire. Il suffiras de rendre le nouveau container instance de Functor, alors quâ€™en C++, si vous utilisiez auparavant des containers de la STL, il vous faudra vous assurer que votre nouvelle structure fournie elle aussi des littÃ©rateurs, ce qui peut Ãªtre assez lourd Ã  fournir, voir impossible si vous nâ€™Ãªtes pas auteur de la classe.</p>

<p>Parmi les instances de Functor il y a donc les listes (les vrais listes []), mais aussi Maybe. On peut donc utiliser Maybe pour utiliser des valeurs dans un contexte. Par exemple :</p>
<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">divideBy</span> <span class="o">::</span> <span class="kt">Int</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="o">-&gt;</span> <span class="kt">Maybe</span> <span class="kt">Int</span>
<span class="n">divideBy</span> <span class="n">n</span> <span class="n">m</span> <span class="o">=</span> <span class="kr">if</span> <span class="n">m</span> <span class="o">==</span> <span class="mi">0</span> <span class="kr">then</span> <span class="kt">Nothing</span> <span class="kr">else</span> <span class="p">(</span><span class="n">n</span> <span class="p">`</span><span class="n">div</span><span class="p">`</span> <span class="n">m</span><span class="p">)</span>


<span class="n">doSomething</span> <span class="o">::</span> <span class="kt">Int</span> <span class="o">-&gt;</span> <span class="kt">Int</span>
<span class="n">doSomething</span> <span class="n">n</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">32</span><span class="p">)</span> <span class="o">*</span> <span class="mi">5</span>


<span class="n">res</span> <span class="o">=</span> <span class="n">fmap</span> <span class="n">doSomething</span> <span class="p">(</span><span class="n">divideBy</span> <span class="mi">3</span> <span class="mi">7</span><span class="p">)</span>
</code></pre></div></div>

<p>Il est trÃ¨s important de bien saisir lâ€™intÃ©rÃªt des foncteurs (qui nâ€™est pas cantonnÃ© aux langages fonctionnels), et leur fonctionnement pour la suite. La derniÃ¨re partie ne traiteras que de leurs spÃ©cialisations : les foncteurs applicatifs et les monades.</p>

<p><strong><em>Point culture :</em></strong> Et si lâ€™on veux un foncteur contravariant en haskell? On peut prendre par exemple le constructeur de type <code class="highlighter-rouge">type Func a = a -&gt; Int</code> et la fonction <code class="highlighter-rouge">map :: (a -&gt; b) -&gt; (b -&gt; Int) -&gt; (a -&gt; Int) ; map f fa = fb . f</code>. On construit bien une fonction de type <code class="highlighter-rouge">a -&gt; Int</code> Ã  partir dâ€™une fonction de type <code class="highlighter-rouge">b -&gt; Int</code>. On a donc â€œinversÃ© les flÃ¨chesâ€, puisque lâ€™on part de â€œa -&gt; bâ€ pour obtenir du â€œFunc b -&gt; Func aâ€.&lt;/i&gt;</p>

<h3 id="rÃ©fÃ©rences-">RÃ©fÃ©rences :</h3>

<ul>
  <li>CatÃ©gories : <a href="http://fr.wikipedia.org/wiki/Th%C3%A9orie_des_cat%C3%A9gories">http://fr.wikipedia.org/wiki/Th%C3%A9orie_des_cat%C3%A9gories</a></li>
  <li>Foncteurs : <a href="http://fr.wikipedia.org/wiki/Foncteur">http://fr.wikipedia.org/wiki/Foncteur</a></li>
  <li>Apprendre Haskell vous fera le plus grand bien : <a href="http://lyah.haskell.fr/&lt;">http://lyah.haskell.fr/&lt;</a> ou <a href="http://learnyouahaskell.com">http://learnyouahaskell.com</a></li>
  <li>Real World Haskell : <a href="http://book.realworldhaskell.org/read/">http://book.realworldhaskell.org/read/</a></li>
  <li>Haskell â€œkindâ€ : <a href="http://www.haskell.org/haskellwiki/Kind">http://www.haskell.org/haskellwiki/Kind</a> (type <code class="highlighter-rouge">:k Maybe</code> and <code class="highlighter-rouge">:k Bool</code> on GHCI)</li>
  <li>La classe functor : <a href="http://en.wikibooks.org/wiki/Haskell/The_Functor_class">http://en.wikibooks.org/wiki/Haskell/The_Functor_class</a></li>
</ul>

</div>

<div class="related">
  <h2>Related Posts</h2>
  <ul class="related-posts">
    
      <li>
        <h3>
          <a href="/list-zipper-swift/">
            List Zipper applied to iOS swift
            <small>24 May 2019</small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/what-is-wrong-with-the-object-paradigm/">
            What is wrong with the object paradigm ?
            <small>17 Feb 2017</small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/boost-property-tree/">
            How to use boost::property_tree to load and write JSON
            <small>21 Dec 2015</small>
          </a>
        </h3>
      </li>
    
  </ul>
</div>

    </div>

    
    <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-10762787-1', 'auto');
    ga('send', 'pageview');
</script>
    

    <footer class="footer">
  <hr/>
  <div class="container">
    <div class="row">
      <p class="text-muted col-sm-10 text-center">
            <span class="sidebar-nav-item small">Make a donation. ğŸ˜‡</span>
            <span class="sidebar-nav-item x-small">BTC: <a href="bitcoin:1JcME7DSCw8b83nEGFKUYTKE4LM8aX4dhJ">1JcME7DSCw8b83nEGFKUYTKE4LM8aX4dhJ</a></span>
            <span class="sidebar-nav-item x-small">ETH: <a href="ethereum:eA22ADf19f20D618D8EF66E4704C540A10708F1F">eA22ADf19f20D618D8EF66E4704C540A10708F1F</a></span>
      </p>
      <p class="col-sm-2">
        <a class="twitter-share-button col-sm"
           href="https://twitter.com/share"
           data-via="Zenol42">
          Tweet
        </a>
      </p>
    </div>
  </div>
</footer>

<!-- Bootstrap core JavaScript
================================================== -->
<!-- Placed at the end of the document so the pages load faster -->
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="/bootstrap/js/vendor/jquery.min.js"><\/script>')</script>
<script src="/public/bootstrap/js/bootstrap.min.js"></script>

<!-- Twitter sharing button loader -->
<script>
  window.twttr = (function(d, s, id) {
    var js, fjs = d.getElementsByTagName(s)[0],
      t = window.twttr || {};
    if (d.getElementById(id)) return t;
    js = d.createElement(s);
    js.id = id;
    js.src = "https://platform.twitter.com/widgets.js";
    fjs.parentNode.insertBefore(js, fjs);

    t._e = [];
    t.ready = function(f) {
      t._e.push(f);
    };

    return t;
  }(document, "script", "twitter-wjs"));
</script>

  </body>
</html>
